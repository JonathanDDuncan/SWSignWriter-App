{"ast":null,"code":"/**\n* @license Angular v9.1.0-next.4+61.sha-e552591.with-local-changes\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google Inc. All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  /**\n   * @fileoverview\n   * @suppress {globalThis,undefinedVars}\n   */\n\n  Zone.__load_patch('Error', function (global, Zone, api) {\n    /*\n     * This code patches Error so that:\n     *   - It ignores un-needed stack frames.\n     *   - It Shows the associated Zone for reach frame.\n     */\n    var blacklistedStackFramesSymbol = api.symbol('blacklistedStackFrames');\n    var NativeError = global[api.symbol('Error')] = global['Error']; // Store the frames which should be removed from the stack frames\n\n    var blackListedStackFrames = {}; // We must find the frame where Error was created, otherwise we assume we don't understand stack\n\n    var zoneAwareFrame1;\n    var zoneAwareFrame2;\n    var zoneAwareFrame1WithoutNew;\n    var zoneAwareFrame2WithoutNew;\n    var zoneAwareFrame3WithoutNew;\n    global['Error'] = ZoneAwareError;\n    var stackRewrite = 'stackRewrite';\n    var blackListedStackFramesPolicy = global['__Zone_Error_BlacklistedStackFrames_policy'] || 'default';\n\n    function buildZoneFrameNames(zoneFrame) {\n      var zoneFrameName = {\n        zoneName: zoneFrame.zone.name\n      };\n      var result = zoneFrameName;\n\n      while (zoneFrame.parent) {\n        zoneFrame = zoneFrame.parent;\n        var parentZoneFrameName = {\n          zoneName: zoneFrame.zone.name\n        };\n        zoneFrameName.parent = parentZoneFrameName;\n        zoneFrameName = parentZoneFrameName;\n      }\n\n      return result;\n    }\n\n    function buildZoneAwareStackFrames(originalStack, zoneFrame, isZoneFrame) {\n      if (isZoneFrame === void 0) {\n        isZoneFrame = true;\n      }\n\n      var frames = originalStack.split('\\n');\n      var i = 0; // Find the first frame\n\n      while (!(frames[i] === zoneAwareFrame1 || frames[i] === zoneAwareFrame2 || frames[i] === zoneAwareFrame1WithoutNew || frames[i] === zoneAwareFrame2WithoutNew || frames[i] === zoneAwareFrame3WithoutNew) && i < frames.length) {\n        i++;\n      }\n\n      for (; i < frames.length && zoneFrame; i++) {\n        var frame = frames[i];\n\n        if (frame.trim()) {\n          switch (blackListedStackFrames[frame]) {\n            case 0\n            /* blackList */\n            :\n              frames.splice(i, 1);\n              i--;\n              break;\n\n            case 1\n            /* transition */\n            :\n              if (zoneFrame.parent) {\n                // This is the special frame where zone changed. Print and process it accordingly\n                zoneFrame = zoneFrame.parent;\n              } else {\n                zoneFrame = null;\n              }\n\n              frames.splice(i, 1);\n              i--;\n              break;\n\n            default:\n              frames[i] += isZoneFrame ? \" [\" + zoneFrame.zone.name + \"]\" : \" [\" + zoneFrame.zoneName + \"]\";\n          }\n        }\n      }\n\n      return frames.join('\\n');\n    }\n    /**\n     * This is ZoneAwareError which processes the stack frame and cleans up extra frames as well as\n     * adds zone information to it.\n     */\n\n\n    function ZoneAwareError() {\n      var _this = this; // We always have to return native error otherwise the browser console will not work.\n\n\n      var error = NativeError.apply(this, arguments); // Save original stack trace\n\n      var originalStack = error['originalStack'] = error.stack; // Process the stack trace and rewrite the frames.\n\n      if (ZoneAwareError[stackRewrite] && originalStack) {\n        var zoneFrame = api.currentZoneFrame();\n\n        if (blackListedStackFramesPolicy === 'lazy') {\n          // don't handle stack trace now\n          error[api.symbol('zoneFrameNames')] = buildZoneFrameNames(zoneFrame);\n        } else if (blackListedStackFramesPolicy === 'default') {\n          try {\n            error.stack = error.zoneAwareStack = buildZoneAwareStackFrames(originalStack, zoneFrame);\n          } catch (e) {// ignore as some browsers don't allow overriding of stack\n          }\n        }\n      }\n\n      if (this instanceof NativeError && this.constructor != NativeError) {\n        // We got called with a `new` operator AND we are subclass of ZoneAwareError\n        // in that case we have to copy all of our properties to `this`.\n        Object.keys(error).concat('stack', 'message').forEach(function (key) {\n          var value = error[key];\n\n          if (value !== undefined) {\n            try {\n              _this[key] = value;\n            } catch (e) {// ignore the assignment in case it is a setter and it throws.\n            }\n          }\n        });\n        return this;\n      }\n\n      return error;\n    } // Copy the prototype so that instanceof operator works as expected\n\n\n    ZoneAwareError.prototype = NativeError.prototype;\n    ZoneAwareError[blacklistedStackFramesSymbol] = blackListedStackFrames;\n    ZoneAwareError[stackRewrite] = false;\n    var zoneAwareStackSymbol = api.symbol('zoneAwareStack'); // try to define zoneAwareStack property when blackListed\n    // policy is delay\n\n    if (blackListedStackFramesPolicy === 'lazy') {\n      Object.defineProperty(ZoneAwareError.prototype, 'zoneAwareStack', {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n          if (!this[zoneAwareStackSymbol]) {\n            this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n          }\n\n          return this[zoneAwareStackSymbol];\n        },\n        set: function set(newStack) {\n          this.originalStack = newStack;\n          this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n        }\n      });\n    } // those properties need special handling\n\n\n    var specialPropertyNames = ['stackTraceLimit', 'captureStackTrace', 'prepareStackTrace']; // those properties of NativeError should be set to ZoneAwareError\n\n    var nativeErrorProperties = Object.keys(NativeError);\n\n    if (nativeErrorProperties) {\n      nativeErrorProperties.forEach(function (prop) {\n        if (specialPropertyNames.filter(function (sp) {\n          return sp === prop;\n        }).length === 0) {\n          Object.defineProperty(ZoneAwareError, prop, {\n            get: function get() {\n              return NativeError[prop];\n            },\n            set: function set(value) {\n              NativeError[prop] = value;\n            }\n          });\n        }\n      });\n    }\n\n    if (NativeError.hasOwnProperty('stackTraceLimit')) {\n      // Extend default stack limit as we will be removing few frames.\n      NativeError.stackTraceLimit = Math.max(NativeError.stackTraceLimit, 15); // make sure that ZoneAwareError has the same property which forwards to NativeError.\n\n      Object.defineProperty(ZoneAwareError, 'stackTraceLimit', {\n        get: function get() {\n          return NativeError.stackTraceLimit;\n        },\n        set: function set(value) {\n          return NativeError.stackTraceLimit = value;\n        }\n      });\n    }\n\n    if (NativeError.hasOwnProperty('captureStackTrace')) {\n      Object.defineProperty(ZoneAwareError, 'captureStackTrace', {\n        // add named function here because we need to remove this\n        // stack frame when prepareStackTrace below\n        value: function zoneCaptureStackTrace(targetObject, constructorOpt) {\n          NativeError.captureStackTrace(targetObject, constructorOpt);\n        }\n      });\n    }\n\n    var ZONE_CAPTURESTACKTRACE = 'zoneCaptureStackTrace';\n    Object.defineProperty(ZoneAwareError, 'prepareStackTrace', {\n      get: function get() {\n        return NativeError.prepareStackTrace;\n      },\n      set: function set(value) {\n        if (!value || typeof value !== 'function') {\n          return NativeError.prepareStackTrace = value;\n        }\n\n        return NativeError.prepareStackTrace = function (error, structuredStackTrace) {\n          // remove additional stack information from ZoneAwareError.captureStackTrace\n          if (structuredStackTrace) {\n            for (var i = 0; i < structuredStackTrace.length; i++) {\n              var st = structuredStackTrace[i]; // remove the first function which name is zoneCaptureStackTrace\n\n              if (st.getFunctionName() === ZONE_CAPTURESTACKTRACE) {\n                structuredStackTrace.splice(i, 1);\n                break;\n              }\n            }\n          }\n\n          return value.call(this, error, structuredStackTrace);\n        };\n      }\n    });\n\n    if (blackListedStackFramesPolicy === 'disable') {\n      // don't need to run detectZone to populate\n      // blacklisted stack frames\n      return;\n    } // Now we need to populate the `blacklistedStackFrames` as well as find the\n    // run/runGuarded/runTask frames. This is done by creating a detect zone and then threading\n    // the execution through all of the above methods so that we can look at the stack trace and\n    // find the frames of interest.\n\n\n    var detectZone = Zone.current.fork({\n      name: 'detect',\n      onHandleError: function onHandleError(parentZD, current, target, error) {\n        if (error.originalStack && Error === ZoneAwareError) {\n          var frames_1 = error.originalStack.split(/\\n/);\n          var runFrame = false,\n              runGuardedFrame = false,\n              runTaskFrame = false;\n\n          while (frames_1.length) {\n            var frame = frames_1.shift(); // On safari it is possible to have stack frame with no line number.\n            // This check makes sure that we don't filter frames on name only (must have\n            // line number or exact equals to `ZoneAwareError`)\n\n            if (/:\\d+:\\d+/.test(frame) || frame === 'ZoneAwareError') {\n              // Get rid of the path so that we don't accidentally find function name in path.\n              // In chrome the separator is `(` and `@` in FF and safari\n              // Chrome: at Zone.run (zone.js:100)\n              // Chrome: at Zone.run (http://localhost:9876/base/build/lib/zone.js:100:24)\n              // FireFox: Zone.prototype.run@http://localhost:9876/base/build/lib/zone.js:101:24\n              // Safari: run@http://localhost:9876/base/build/lib/zone.js:101:24\n              var fnName = frame.split('(')[0].split('@')[0];\n              var frameType = 1\n              /* transition */\n              ;\n\n              if (fnName.indexOf('ZoneAwareError') !== -1) {\n                if (fnName.indexOf('new ZoneAwareError') !== -1) {\n                  zoneAwareFrame1 = frame;\n                  zoneAwareFrame2 = frame.replace('new ZoneAwareError', 'new Error.ZoneAwareError');\n                } else {\n                  zoneAwareFrame1WithoutNew = frame;\n                  zoneAwareFrame2WithoutNew = frame.replace('Error.', '');\n\n                  if (frame.indexOf('Error.ZoneAwareError') === -1) {\n                    zoneAwareFrame3WithoutNew = frame.replace('ZoneAwareError', 'Error.ZoneAwareError');\n                  }\n                }\n\n                blackListedStackFrames[zoneAwareFrame2] = 0\n                /* blackList */\n                ;\n              }\n\n              if (fnName.indexOf('runGuarded') !== -1) {\n                runGuardedFrame = true;\n              } else if (fnName.indexOf('runTask') !== -1) {\n                runTaskFrame = true;\n              } else if (fnName.indexOf('run') !== -1) {\n                runFrame = true;\n              } else {\n                frameType = 0\n                /* blackList */\n                ;\n              }\n\n              blackListedStackFrames[frame] = frameType; // Once we find all of the frames we can stop looking.\n\n              if (runFrame && runGuardedFrame && runTaskFrame) {\n                ZoneAwareError[stackRewrite] = true;\n                break;\n              }\n            }\n          }\n        }\n\n        return false;\n      }\n    }); // carefully constructor a stack frame which contains all of the frames of interest which\n    // need to be detected and blacklisted.\n\n    var childDetectZone = detectZone.fork({\n      name: 'child',\n      onScheduleTask: function onScheduleTask(delegate, curr, target, task) {\n        return delegate.scheduleTask(target, task);\n      },\n      onInvokeTask: function onInvokeTask(delegate, curr, target, task, applyThis, applyArgs) {\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      },\n      onCancelTask: function onCancelTask(delegate, curr, target, task) {\n        return delegate.cancelTask(target, task);\n      },\n      onInvoke: function onInvoke(delegate, curr, target, callback, applyThis, applyArgs, source) {\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      }\n    }); // we need to detect all zone related frames, it will\n    // exceed default stackTraceLimit, so we set it to\n    // larger number here, and restore it after detect finish.\n    // We cast through any so we don't need to depend on nodejs typings.\n\n    var originalStackTraceLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 100; // we schedule event/micro/macro task, and invoke them\n    // when onSchedule, so we can get all stack traces for\n    // all kinds of tasks with one error thrown.\n\n    childDetectZone.run(function () {\n      childDetectZone.runGuarded(function () {\n        var fakeTransitionTo = function fakeTransitionTo() {};\n\n        childDetectZone.scheduleEventTask(blacklistedStackFramesSymbol, function () {\n          childDetectZone.scheduleMacroTask(blacklistedStackFramesSymbol, function () {\n            childDetectZone.scheduleMicroTask(blacklistedStackFramesSymbol, function () {\n              throw new Error();\n            }, undefined, function (t) {\n              t._transitionTo = fakeTransitionTo;\n              t.invoke();\n            });\n            childDetectZone.scheduleMicroTask(blacklistedStackFramesSymbol, function () {\n              throw Error();\n            }, undefined, function (t) {\n              t._transitionTo = fakeTransitionTo;\n              t.invoke();\n            });\n          }, undefined, function (t) {\n            t._transitionTo = fakeTransitionTo;\n            t.invoke();\n          }, function () {});\n        }, undefined, function (t) {\n          t._transitionTo = fakeTransitionTo;\n          t.invoke();\n        }, function () {});\n      });\n    });\n    Error.stackTraceLimit = originalStackTraceLimit;\n  });\n});","map":{"version":3,"sources":["C:/Users/Fernando Martinez/Documents/Programacion/SignWriter/Frontend JD/node_modules/zone.js/dist/zone-error.js"],"names":["factory","define","amd","Zone","__load_patch","global","api","blacklistedStackFramesSymbol","symbol","NativeError","blackListedStackFrames","zoneAwareFrame1","zoneAwareFrame2","zoneAwareFrame1WithoutNew","zoneAwareFrame2WithoutNew","zoneAwareFrame3WithoutNew","ZoneAwareError","stackRewrite","blackListedStackFramesPolicy","buildZoneFrameNames","zoneFrame","zoneFrameName","zoneName","zone","name","result","parent","parentZoneFrameName","buildZoneAwareStackFrames","originalStack","isZoneFrame","frames","split","i","length","frame","trim","splice","join","_this","error","apply","arguments","stack","currentZoneFrame","zoneAwareStack","e","constructor","Object","keys","concat","forEach","key","value","undefined","prototype","zoneAwareStackSymbol","defineProperty","configurable","enumerable","get","set","newStack","specialPropertyNames","nativeErrorProperties","prop","filter","sp","hasOwnProperty","stackTraceLimit","Math","max","zoneCaptureStackTrace","targetObject","constructorOpt","captureStackTrace","ZONE_CAPTURESTACKTRACE","prepareStackTrace","structuredStackTrace","st","getFunctionName","call","detectZone","current","fork","onHandleError","parentZD","target","Error","frames_1","runFrame","runGuardedFrame","runTaskFrame","shift","test","fnName","frameType","indexOf","replace","childDetectZone","onScheduleTask","delegate","curr","task","scheduleTask","onInvokeTask","applyThis","applyArgs","invokeTask","onCancelTask","cancelTask","onInvoke","callback","source","invoke","originalStackTraceLimit","run","runGuarded","fakeTransitionTo","scheduleEventTask","scheduleMacroTask","scheduleMicroTask","t","_transitionTo"],"mappings":"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","sourcesContent":["/**\n* @license Angular v9.1.0-next.4+61.sha-e552591.with-local-changes\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n}((function () {\n    'use strict';\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @fileoverview\n     * @suppress {globalThis,undefinedVars}\n     */\n    Zone.__load_patch('Error', function (global, Zone, api) {\n        /*\n         * This code patches Error so that:\n         *   - It ignores un-needed stack frames.\n         *   - It Shows the associated Zone for reach frame.\n         */\n        var blacklistedStackFramesSymbol = api.symbol('blacklistedStackFrames');\n        var NativeError = global[api.symbol('Error')] = global['Error'];\n        // Store the frames which should be removed from the stack frames\n        var blackListedStackFrames = {};\n        // We must find the frame where Error was created, otherwise we assume we don't understand stack\n        var zoneAwareFrame1;\n        var zoneAwareFrame2;\n        var zoneAwareFrame1WithoutNew;\n        var zoneAwareFrame2WithoutNew;\n        var zoneAwareFrame3WithoutNew;\n        global['Error'] = ZoneAwareError;\n        var stackRewrite = 'stackRewrite';\n        var blackListedStackFramesPolicy = global['__Zone_Error_BlacklistedStackFrames_policy'] || 'default';\n        function buildZoneFrameNames(zoneFrame) {\n            var zoneFrameName = { zoneName: zoneFrame.zone.name };\n            var result = zoneFrameName;\n            while (zoneFrame.parent) {\n                zoneFrame = zoneFrame.parent;\n                var parentZoneFrameName = { zoneName: zoneFrame.zone.name };\n                zoneFrameName.parent = parentZoneFrameName;\n                zoneFrameName = parentZoneFrameName;\n            }\n            return result;\n        }\n        function buildZoneAwareStackFrames(originalStack, zoneFrame, isZoneFrame) {\n            if (isZoneFrame === void 0) { isZoneFrame = true; }\n            var frames = originalStack.split('\\n');\n            var i = 0;\n            // Find the first frame\n            while (!(frames[i] === zoneAwareFrame1 || frames[i] === zoneAwareFrame2 ||\n                frames[i] === zoneAwareFrame1WithoutNew || frames[i] === zoneAwareFrame2WithoutNew ||\n                frames[i] === zoneAwareFrame3WithoutNew) &&\n                i < frames.length) {\n                i++;\n            }\n            for (; i < frames.length && zoneFrame; i++) {\n                var frame = frames[i];\n                if (frame.trim()) {\n                    switch (blackListedStackFrames[frame]) {\n                        case 0 /* blackList */:\n                            frames.splice(i, 1);\n                            i--;\n                            break;\n                        case 1 /* transition */:\n                            if (zoneFrame.parent) {\n                                // This is the special frame where zone changed. Print and process it accordingly\n                                zoneFrame = zoneFrame.parent;\n                            }\n                            else {\n                                zoneFrame = null;\n                            }\n                            frames.splice(i, 1);\n                            i--;\n                            break;\n                        default:\n                            frames[i] += isZoneFrame ? \" [\" + zoneFrame.zone.name + \"]\" :\n                                \" [\" + zoneFrame.zoneName + \"]\";\n                    }\n                }\n            }\n            return frames.join('\\n');\n        }\n        /**\n         * This is ZoneAwareError which processes the stack frame and cleans up extra frames as well as\n         * adds zone information to it.\n         */\n        function ZoneAwareError() {\n            var _this = this;\n            // We always have to return native error otherwise the browser console will not work.\n            var error = NativeError.apply(this, arguments);\n            // Save original stack trace\n            var originalStack = error['originalStack'] = error.stack;\n            // Process the stack trace and rewrite the frames.\n            if (ZoneAwareError[stackRewrite] && originalStack) {\n                var zoneFrame = api.currentZoneFrame();\n                if (blackListedStackFramesPolicy === 'lazy') {\n                    // don't handle stack trace now\n                    error[api.symbol('zoneFrameNames')] = buildZoneFrameNames(zoneFrame);\n                }\n                else if (blackListedStackFramesPolicy === 'default') {\n                    try {\n                        error.stack = error.zoneAwareStack = buildZoneAwareStackFrames(originalStack, zoneFrame);\n                    }\n                    catch (e) {\n                        // ignore as some browsers don't allow overriding of stack\n                    }\n                }\n            }\n            if (this instanceof NativeError && this.constructor != NativeError) {\n                // We got called with a `new` operator AND we are subclass of ZoneAwareError\n                // in that case we have to copy all of our properties to `this`.\n                Object.keys(error).concat('stack', 'message').forEach(function (key) {\n                    var value = error[key];\n                    if (value !== undefined) {\n                        try {\n                            _this[key] = value;\n                        }\n                        catch (e) {\n                            // ignore the assignment in case it is a setter and it throws.\n                        }\n                    }\n                });\n                return this;\n            }\n            return error;\n        }\n        // Copy the prototype so that instanceof operator works as expected\n        ZoneAwareError.prototype = NativeError.prototype;\n        ZoneAwareError[blacklistedStackFramesSymbol] = blackListedStackFrames;\n        ZoneAwareError[stackRewrite] = false;\n        var zoneAwareStackSymbol = api.symbol('zoneAwareStack');\n        // try to define zoneAwareStack property when blackListed\n        // policy is delay\n        if (blackListedStackFramesPolicy === 'lazy') {\n            Object.defineProperty(ZoneAwareError.prototype, 'zoneAwareStack', {\n                configurable: true,\n                enumerable: true,\n                get: function () {\n                    if (!this[zoneAwareStackSymbol]) {\n                        this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n                    }\n                    return this[zoneAwareStackSymbol];\n                },\n                set: function (newStack) {\n                    this.originalStack = newStack;\n                    this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n                }\n            });\n        }\n        // those properties need special handling\n        var specialPropertyNames = ['stackTraceLimit', 'captureStackTrace', 'prepareStackTrace'];\n        // those properties of NativeError should be set to ZoneAwareError\n        var nativeErrorProperties = Object.keys(NativeError);\n        if (nativeErrorProperties) {\n            nativeErrorProperties.forEach(function (prop) {\n                if (specialPropertyNames.filter(function (sp) { return sp === prop; }).length === 0) {\n                    Object.defineProperty(ZoneAwareError, prop, {\n                        get: function () { return NativeError[prop]; },\n                        set: function (value) { NativeError[prop] = value; }\n                    });\n                }\n            });\n        }\n        if (NativeError.hasOwnProperty('stackTraceLimit')) {\n            // Extend default stack limit as we will be removing few frames.\n            NativeError.stackTraceLimit = Math.max(NativeError.stackTraceLimit, 15);\n            // make sure that ZoneAwareError has the same property which forwards to NativeError.\n            Object.defineProperty(ZoneAwareError, 'stackTraceLimit', {\n                get: function () { return NativeError.stackTraceLimit; },\n                set: function (value) { return NativeError.stackTraceLimit = value; }\n            });\n        }\n        if (NativeError.hasOwnProperty('captureStackTrace')) {\n            Object.defineProperty(ZoneAwareError, 'captureStackTrace', {\n                // add named function here because we need to remove this\n                // stack frame when prepareStackTrace below\n                value: function zoneCaptureStackTrace(targetObject, constructorOpt) {\n                    NativeError.captureStackTrace(targetObject, constructorOpt);\n                }\n            });\n        }\n        var ZONE_CAPTURESTACKTRACE = 'zoneCaptureStackTrace';\n        Object.defineProperty(ZoneAwareError, 'prepareStackTrace', {\n            get: function () { return NativeError.prepareStackTrace; },\n            set: function (value) {\n                if (!value || typeof value !== 'function') {\n                    return NativeError.prepareStackTrace = value;\n                }\n                return NativeError.prepareStackTrace = function (error, structuredStackTrace) {\n                    // remove additional stack information from ZoneAwareError.captureStackTrace\n                    if (structuredStackTrace) {\n                        for (var i = 0; i < structuredStackTrace.length; i++) {\n                            var st = structuredStackTrace[i];\n                            // remove the first function which name is zoneCaptureStackTrace\n                            if (st.getFunctionName() === ZONE_CAPTURESTACKTRACE) {\n                                structuredStackTrace.splice(i, 1);\n                                break;\n                            }\n                        }\n                    }\n                    return value.call(this, error, structuredStackTrace);\n                };\n            }\n        });\n        if (blackListedStackFramesPolicy === 'disable') {\n            // don't need to run detectZone to populate\n            // blacklisted stack frames\n            return;\n        }\n        // Now we need to populate the `blacklistedStackFrames` as well as find the\n        // run/runGuarded/runTask frames. This is done by creating a detect zone and then threading\n        // the execution through all of the above methods so that we can look at the stack trace and\n        // find the frames of interest.\n        var detectZone = Zone.current.fork({\n            name: 'detect',\n            onHandleError: function (parentZD, current, target, error) {\n                if (error.originalStack && Error === ZoneAwareError) {\n                    var frames_1 = error.originalStack.split(/\\n/);\n                    var runFrame = false, runGuardedFrame = false, runTaskFrame = false;\n                    while (frames_1.length) {\n                        var frame = frames_1.shift();\n                        // On safari it is possible to have stack frame with no line number.\n                        // This check makes sure that we don't filter frames on name only (must have\n                        // line number or exact equals to `ZoneAwareError`)\n                        if (/:\\d+:\\d+/.test(frame) || frame === 'ZoneAwareError') {\n                            // Get rid of the path so that we don't accidentally find function name in path.\n                            // In chrome the separator is `(` and `@` in FF and safari\n                            // Chrome: at Zone.run (zone.js:100)\n                            // Chrome: at Zone.run (http://localhost:9876/base/build/lib/zone.js:100:24)\n                            // FireFox: Zone.prototype.run@http://localhost:9876/base/build/lib/zone.js:101:24\n                            // Safari: run@http://localhost:9876/base/build/lib/zone.js:101:24\n                            var fnName = frame.split('(')[0].split('@')[0];\n                            var frameType = 1 /* transition */;\n                            if (fnName.indexOf('ZoneAwareError') !== -1) {\n                                if (fnName.indexOf('new ZoneAwareError') !== -1) {\n                                    zoneAwareFrame1 = frame;\n                                    zoneAwareFrame2 = frame.replace('new ZoneAwareError', 'new Error.ZoneAwareError');\n                                }\n                                else {\n                                    zoneAwareFrame1WithoutNew = frame;\n                                    zoneAwareFrame2WithoutNew = frame.replace('Error.', '');\n                                    if (frame.indexOf('Error.ZoneAwareError') === -1) {\n                                        zoneAwareFrame3WithoutNew =\n                                            frame.replace('ZoneAwareError', 'Error.ZoneAwareError');\n                                    }\n                                }\n                                blackListedStackFrames[zoneAwareFrame2] = 0 /* blackList */;\n                            }\n                            if (fnName.indexOf('runGuarded') !== -1) {\n                                runGuardedFrame = true;\n                            }\n                            else if (fnName.indexOf('runTask') !== -1) {\n                                runTaskFrame = true;\n                            }\n                            else if (fnName.indexOf('run') !== -1) {\n                                runFrame = true;\n                            }\n                            else {\n                                frameType = 0 /* blackList */;\n                            }\n                            blackListedStackFrames[frame] = frameType;\n                            // Once we find all of the frames we can stop looking.\n                            if (runFrame && runGuardedFrame && runTaskFrame) {\n                                ZoneAwareError[stackRewrite] = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                return false;\n            }\n        });\n        // carefully constructor a stack frame which contains all of the frames of interest which\n        // need to be detected and blacklisted.\n        var childDetectZone = detectZone.fork({\n            name: 'child',\n            onScheduleTask: function (delegate, curr, target, task) {\n                return delegate.scheduleTask(target, task);\n            },\n            onInvokeTask: function (delegate, curr, target, task, applyThis, applyArgs) {\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            },\n            onCancelTask: function (delegate, curr, target, task) {\n                return delegate.cancelTask(target, task);\n            },\n            onInvoke: function (delegate, curr, target, callback, applyThis, applyArgs, source) {\n                return delegate.invoke(target, callback, applyThis, applyArgs, source);\n            }\n        });\n        // we need to detect all zone related frames, it will\n        // exceed default stackTraceLimit, so we set it to\n        // larger number here, and restore it after detect finish.\n        // We cast through any so we don't need to depend on nodejs typings.\n        var originalStackTraceLimit = Error.stackTraceLimit;\n        Error.stackTraceLimit = 100;\n        // we schedule event/micro/macro task, and invoke them\n        // when onSchedule, so we can get all stack traces for\n        // all kinds of tasks with one error thrown.\n        childDetectZone.run(function () {\n            childDetectZone.runGuarded(function () {\n                var fakeTransitionTo = function () { };\n                childDetectZone.scheduleEventTask(blacklistedStackFramesSymbol, function () {\n                    childDetectZone.scheduleMacroTask(blacklistedStackFramesSymbol, function () {\n                        childDetectZone.scheduleMicroTask(blacklistedStackFramesSymbol, function () { throw new Error(); }, undefined, function (t) {\n                            t._transitionTo = fakeTransitionTo;\n                            t.invoke();\n                        });\n                        childDetectZone.scheduleMicroTask(blacklistedStackFramesSymbol, function () { throw Error(); }, undefined, function (t) {\n                            t._transitionTo = fakeTransitionTo;\n                            t.invoke();\n                        });\n                    }, undefined, function (t) {\n                        t._transitionTo = fakeTransitionTo;\n                        t.invoke();\n                    }, function () { });\n                }, undefined, function (t) {\n                    t._transitionTo = fakeTransitionTo;\n                    t.invoke();\n                }, function () { });\n            });\n        });\n        Error.stackTraceLimit = originalStackTraceLimit;\n    });\n})));\n"]},"metadata":{},"sourceType":"script"}
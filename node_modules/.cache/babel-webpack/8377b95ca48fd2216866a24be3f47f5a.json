{"ast":null,"code":"'use strict';\n\nvar asn1 = require('asn1.js'),\n    Buffer = require('safe-buffer').Buffer,\n    EC = require('elliptic').ec;\n\nvar b64ToBn = require('./b64-to-bn');\n\nvar PublicKeyInfo = require('./asn1/public-key-info'),\n    PrivateKeyInfo = require('./asn1/private-key-info'),\n    Version = require('./asn1/version');\n\nvar ECParameters = asn1.define('ECParameters',\n/* @this */\nfunction () {\n  this.choice({\n    namedCurve: this.objid()\n  });\n});\nvar ecPrivkeyVer1 = 1;\nvar ECPrivateKey = asn1.define('ECPrivateKey',\n/* @this */\nfunction () {\n  this.seq().obj(this.key('version').use(Version), this.key('privateKey').octstr(), this.key('parameters').explicit(0).optional().any(), this.key('publicKey').explicit(1).optional().bitstr());\n});\nvar curves = {\n  'P-256': 'p256',\n  'P-384': 'p384',\n  'P-521': 'p521'\n};\nvar oids = {\n  'P-256': [1, 2, 840, 10045, 3, 1, 7],\n  'P-384': [1, 3, 132, 0, 34],\n  'P-521': [1, 3, 132, 0, 35]\n};\nvar parameters = {};\nvar algorithms = {};\nObject.keys(oids).forEach(function (crv) {\n  parameters[crv] = ECParameters.encode({\n    type: 'namedCurve',\n    value: oids[crv]\n  }, 'der');\n  algorithms[crv] = {\n    algorithm: [1, 2, 840, 10045, 2, 1],\n    parameters: parameters[crv]\n  };\n});\noids = null;\n\nfunction ecJwkToBuffer(jwk, opts) {\n  if ('string' !== typeof jwk.crv) {\n    throw new TypeError('Expected \"jwk.crv\" to be a String');\n  }\n\n  var hasD = 'string' === typeof jwk.d;\n  var xyTypes = hasD ? ['undefined', 'string'] : ['string'];\n\n  if (-1 === xyTypes.indexOf(typeof jwk.x)) {\n    throw new TypeError('Expected \"jwk.x\" to be a String');\n  }\n\n  if (-1 === xyTypes.indexOf(typeof jwk.y)) {\n    throw new TypeError('Expected \"jwk.y\" to be a String');\n  }\n\n  if (opts.private && !hasD) {\n    throw new TypeError('Expected \"jwk.d\" to be a String');\n  }\n\n  var curveName = curves[jwk.crv];\n\n  if (!curveName) {\n    throw new Error('Unsupported curve \"' + jwk.crv + '\"');\n  }\n\n  var curve = new EC(curveName);\n  var key = {};\n  var hasPub = jwk.x && jwk.y;\n\n  if (hasPub) {\n    key.pub = {\n      x: b64ToBn(jwk.x, false),\n      y: b64ToBn(jwk.y, false)\n    };\n  }\n\n  if (opts.private || !hasPub) {\n    key.priv = b64ToBn(jwk.d, true);\n  }\n\n  key = curve.keyPair(key);\n  var keyValidation = key.validate();\n\n  if (!keyValidation.result) {\n    throw new Error('Invalid key for curve: \"' + keyValidation.reason + '\"');\n  }\n\n  var result = keyToPem(jwk.crv, key, opts);\n  return result;\n}\n\nfunction keyToPem(crv, key, opts) {\n  var compact = false;\n  var publicKey = key.getPublic(compact, 'hex');\n  publicKey = Buffer.from(publicKey, 'hex');\n  publicKey = {\n    unused: 0,\n    data: publicKey\n  };\n  var result;\n\n  if (opts.private) {\n    var privateKey = key.getPrivate('hex');\n    privateKey = Buffer.from(privateKey, 'hex');\n    result = PrivateKeyInfo.encode({\n      version: 0,\n      privateKeyAlgorithm: algorithms[crv],\n      privateKey: ECPrivateKey.encode({\n        version: ecPrivkeyVer1,\n        privateKey: privateKey,\n        parameters: parameters[crv],\n        publicKey: publicKey\n      }, 'der')\n    }, 'pem', {\n      label: 'PRIVATE KEY'\n    });\n    privateKey.fill(0);\n  } else {\n    result = PublicKeyInfo.encode({\n      algorithm: algorithms[crv],\n      PublicKey: publicKey\n    }, 'pem', {\n      label: 'PUBLIC KEY'\n    });\n  } // This is in an if incase asn1.js adds a trailing \\n\n  // istanbul ignore else\n\n\n  if ('\\n' !== result.slice(-1)) {\n    result += '\\n';\n  }\n\n  return result;\n}\n\nmodule.exports = ecJwkToBuffer;","map":{"version":3,"sources":["C:/Users/Fernando Martinez/Documents/Programacion/SignWriter/Frontend JD/node_modules/jwk-to-pem/src/ec.js"],"names":["asn1","require","Buffer","EC","ec","b64ToBn","PublicKeyInfo","PrivateKeyInfo","Version","ECParameters","define","choice","namedCurve","objid","ecPrivkeyVer1","ECPrivateKey","seq","obj","key","use","octstr","explicit","optional","any","bitstr","curves","oids","parameters","algorithms","Object","keys","forEach","crv","encode","type","value","algorithm","ecJwkToBuffer","jwk","opts","TypeError","hasD","d","xyTypes","indexOf","x","y","private","curveName","Error","curve","hasPub","pub","priv","keyPair","keyValidation","validate","result","reason","keyToPem","compact","publicKey","getPublic","from","unused","data","privateKey","getPrivate","version","privateKeyAlgorithm","label","fill","PublicKey","slice","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,SAAD,CAAlB;AAAA,IACCC,MAAM,GAAGD,OAAO,CAAC,aAAD,CAAP,CAAuBC,MADjC;AAAA,IAECC,EAAE,GAAGF,OAAO,CAAC,UAAD,CAAP,CAAoBG,EAF1B;;AAIA,IAAIC,OAAO,GAAGJ,OAAO,CAAC,aAAD,CAArB;;AAEA,IAAIK,aAAa,GAAGL,OAAO,CAAC,wBAAD,CAA3B;AAAA,IACCM,cAAc,GAAGN,OAAO,CAAC,yBAAD,CADzB;AAAA,IAECO,OAAO,GAAGP,OAAO,CAAC,gBAAD,CAFlB;;AAIA,IAAIQ,YAAY,GAAGT,IAAI,CAACU,MAAL,CAAY,cAAZ;AAA4B;AAAY,YAAW;AACrE,OAAKC,MAAL,CAAY;AACXC,IAAAA,UAAU,EAAE,KAAKC,KAAL;AADD,GAAZ;AAGA,CAJkB,CAAnB;AAMA,IAAIC,aAAa,GAAG,CAApB;AAEA,IAAIC,YAAY,GAAGf,IAAI,CAACU,MAAL,CAAY,cAAZ;AAA4B;AAAY,YAAW;AACrE,OAAKM,GAAL,GAAWC,GAAX,CACC,KAAKC,GAAL,CAAS,SAAT,EAAoBC,GAApB,CAAwBX,OAAxB,CADD,EAEC,KAAKU,GAAL,CAAS,YAAT,EAAuBE,MAAvB,EAFD,EAGC,KAAKF,GAAL,CAAS,YAAT,EAAuBG,QAAvB,CAAgC,CAAhC,EAAmCC,QAAnC,GAA8CC,GAA9C,EAHD,EAIC,KAAKL,GAAL,CAAS,WAAT,EAAsBG,QAAtB,CAA+B,CAA/B,EAAkCC,QAAlC,GAA6CE,MAA7C,EAJD;AAMA,CAPkB,CAAnB;AASA,IAAIC,MAAM,GAAG;AACZ,WAAS,MADG;AAEZ,WAAS,MAFG;AAGZ,WAAS;AAHG,CAAb;AAMA,IAAIC,IAAI,GAAG;AACV,WAAS,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,EAAY,KAAZ,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CADC;AAEV,WAAS,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,EAAY,CAAZ,EAAe,EAAf,CAFC;AAGV,WAAS,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,EAAY,CAAZ,EAAe,EAAf;AAHC,CAAX;AAKA,IAAIC,UAAU,GAAG,EAAjB;AACA,IAAIC,UAAU,GAAG,EAAjB;AACAC,MAAM,CAACC,IAAP,CAAYJ,IAAZ,EAAkBK,OAAlB,CAA0B,UAASC,GAAT,EAAc;AACvCL,EAAAA,UAAU,CAACK,GAAD,CAAV,GAAkBvB,YAAY,CAACwB,MAAb,CAAoB;AACrCC,IAAAA,IAAI,EAAE,YAD+B;AAErCC,IAAAA,KAAK,EAAET,IAAI,CAACM,GAAD;AAF0B,GAApB,EAGf,KAHe,CAAlB;AAIAJ,EAAAA,UAAU,CAACI,GAAD,CAAV,GAAkB;AACjBI,IAAAA,SAAS,EAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,GAAP,EAAY,KAAZ,EAAmB,CAAnB,EAAsB,CAAtB,CADK;AAEjBT,IAAAA,UAAU,EAAEA,UAAU,CAACK,GAAD;AAFL,GAAlB;AAIA,CATD;AAUAN,IAAI,GAAG,IAAP;;AAEA,SAASW,aAAT,CAAuBC,GAAvB,EAA4BC,IAA5B,EAAkC;AACjC,MAAI,aAAa,OAAOD,GAAG,CAACN,GAA5B,EAAiC;AAChC,UAAM,IAAIQ,SAAJ,CAAc,mCAAd,CAAN;AACA;;AAED,MAAIC,IAAI,GAAG,aAAa,OAAOH,GAAG,CAACI,CAAnC;AACA,MAAIC,OAAO,GAAGF,IAAI,GACf,CAAC,WAAD,EAAc,QAAd,CADe,GAEf,CAAC,QAAD,CAFH;;AAIA,MAAI,CAAC,CAAD,KAAOE,OAAO,CAACC,OAAR,CAAgB,OAAON,GAAG,CAACO,CAA3B,CAAX,EAA0C;AACzC,UAAM,IAAIL,SAAJ,CAAc,iCAAd,CAAN;AACA;;AAED,MAAI,CAAC,CAAD,KAAOG,OAAO,CAACC,OAAR,CAAgB,OAAON,GAAG,CAACQ,CAA3B,CAAX,EAA0C;AACzC,UAAM,IAAIN,SAAJ,CAAc,iCAAd,CAAN;AACA;;AAED,MAAID,IAAI,CAACQ,OAAL,IAAgB,CAACN,IAArB,EAA2B;AAC1B,UAAM,IAAID,SAAJ,CAAc,iCAAd,CAAN;AACA;;AAED,MAAIQ,SAAS,GAAGvB,MAAM,CAACa,GAAG,CAACN,GAAL,CAAtB;;AACA,MAAI,CAACgB,SAAL,EAAgB;AACf,UAAM,IAAIC,KAAJ,CAAU,wBAAwBX,GAAG,CAACN,GAA5B,GAAkC,GAA5C,CAAN;AACA;;AAED,MAAIkB,KAAK,GAAG,IAAI/C,EAAJ,CAAO6C,SAAP,CAAZ;AAEA,MAAI9B,GAAG,GAAG,EAAV;AAEA,MAAIiC,MAAM,GAAGb,GAAG,CAACO,CAAJ,IAASP,GAAG,CAACQ,CAA1B;;AACA,MAAIK,MAAJ,EAAY;AACXjC,IAAAA,GAAG,CAACkC,GAAJ,GAAU;AACTP,MAAAA,CAAC,EAAExC,OAAO,CAACiC,GAAG,CAACO,CAAL,EAAQ,KAAR,CADD;AAETC,MAAAA,CAAC,EAAEzC,OAAO,CAACiC,GAAG,CAACQ,CAAL,EAAQ,KAAR;AAFD,KAAV;AAIA;;AAED,MAAIP,IAAI,CAACQ,OAAL,IAAgB,CAACI,MAArB,EAA6B;AAC5BjC,IAAAA,GAAG,CAACmC,IAAJ,GAAWhD,OAAO,CAACiC,GAAG,CAACI,CAAL,EAAQ,IAAR,CAAlB;AACA;;AAEDxB,EAAAA,GAAG,GAAGgC,KAAK,CAACI,OAAN,CAAcpC,GAAd,CAAN;AAEA,MAAIqC,aAAa,GAAGrC,GAAG,CAACsC,QAAJ,EAApB;;AACA,MAAI,CAACD,aAAa,CAACE,MAAnB,EAA2B;AAC1B,UAAM,IAAIR,KAAJ,CAAU,6BAA6BM,aAAa,CAACG,MAA3C,GAAoD,GAA9D,CAAN;AACA;;AAED,MAAID,MAAM,GAAGE,QAAQ,CAACrB,GAAG,CAACN,GAAL,EAAUd,GAAV,EAAeqB,IAAf,CAArB;AAEA,SAAOkB,MAAP;AACA;;AAED,SAASE,QAAT,CAAkB3B,GAAlB,EAAuBd,GAAvB,EAA4BqB,IAA5B,EAAkC;AACjC,MAAIqB,OAAO,GAAG,KAAd;AACA,MAAIC,SAAS,GAAG3C,GAAG,CAAC4C,SAAJ,CAAcF,OAAd,EAAuB,KAAvB,CAAhB;AACAC,EAAAA,SAAS,GAAG3D,MAAM,CAAC6D,IAAP,CAAYF,SAAZ,EAAuB,KAAvB,CAAZ;AACAA,EAAAA,SAAS,GAAG;AACXG,IAAAA,MAAM,EAAE,CADG;AAEXC,IAAAA,IAAI,EAAEJ;AAFK,GAAZ;AAKA,MAAIJ,MAAJ;;AACA,MAAIlB,IAAI,CAACQ,OAAT,EAAkB;AACjB,QAAImB,UAAU,GAAGhD,GAAG,CAACiD,UAAJ,CAAe,KAAf,CAAjB;AACAD,IAAAA,UAAU,GAAGhE,MAAM,CAAC6D,IAAP,CAAYG,UAAZ,EAAwB,KAAxB,CAAb;AAEAT,IAAAA,MAAM,GAAGlD,cAAc,CAAC0B,MAAf,CAAsB;AAC9BmC,MAAAA,OAAO,EAAE,CADqB;AAE9BC,MAAAA,mBAAmB,EAAEzC,UAAU,CAACI,GAAD,CAFD;AAG9BkC,MAAAA,UAAU,EAAEnD,YAAY,CAACkB,MAAb,CAAoB;AAC/BmC,QAAAA,OAAO,EAAEtD,aADsB;AAE/BoD,QAAAA,UAAU,EAAEA,UAFmB;AAG/BvC,QAAAA,UAAU,EAAEA,UAAU,CAACK,GAAD,CAHS;AAI/B6B,QAAAA,SAAS,EAAEA;AAJoB,OAApB,EAKT,KALS;AAHkB,KAAtB,EASN,KATM,EASC;AACTS,MAAAA,KAAK,EAAE;AADE,KATD,CAAT;AAaAJ,IAAAA,UAAU,CAACK,IAAX,CAAgB,CAAhB;AACA,GAlBD,MAkBO;AACNd,IAAAA,MAAM,GAAGnD,aAAa,CAAC2B,MAAd,CAAqB;AAC7BG,MAAAA,SAAS,EAAER,UAAU,CAACI,GAAD,CADQ;AAE7BwC,MAAAA,SAAS,EAAEX;AAFkB,KAArB,EAGN,KAHM,EAGC;AACTS,MAAAA,KAAK,EAAE;AADE,KAHD,CAAT;AAMA,GAnCgC,CAqCjC;AACA;;;AACA,MAAI,SAASb,MAAM,CAACgB,KAAP,CAAa,CAAC,CAAd,CAAb,EAA+B;AAC9BhB,IAAAA,MAAM,IAAI,IAAV;AACA;;AAED,SAAOA,MAAP;AACA;;AAEDiB,MAAM,CAACC,OAAP,GAAiBtC,aAAjB","sourcesContent":["'use strict';\n\nvar asn1 = require('asn1.js'),\n\tBuffer = require('safe-buffer').Buffer,\n\tEC = require('elliptic').ec;\n\nvar b64ToBn = require('./b64-to-bn');\n\nvar PublicKeyInfo = require('./asn1/public-key-info'),\n\tPrivateKeyInfo = require('./asn1/private-key-info'),\n\tVersion = require('./asn1/version');\n\nvar ECParameters = asn1.define('ECParameters', /* @this */ function() {\n\tthis.choice({\n\t\tnamedCurve: this.objid()\n\t});\n});\n\nvar ecPrivkeyVer1 = 1;\n\nvar ECPrivateKey = asn1.define('ECPrivateKey', /* @this */ function() {\n\tthis.seq().obj(\n\t\tthis.key('version').use(Version),\n\t\tthis.key('privateKey').octstr(),\n\t\tthis.key('parameters').explicit(0).optional().any(),\n\t\tthis.key('publicKey').explicit(1).optional().bitstr()\n\t);\n});\n\nvar curves = {\n\t'P-256': 'p256',\n\t'P-384': 'p384',\n\t'P-521': 'p521'\n};\n\nvar oids = {\n\t'P-256': [1, 2, 840, 10045, 3, 1, 7],\n\t'P-384': [1, 3, 132, 0, 34],\n\t'P-521': [1, 3, 132, 0, 35]\n};\nvar parameters = {};\nvar algorithms = {};\nObject.keys(oids).forEach(function(crv) {\n\tparameters[crv] = ECParameters.encode({\n\t\ttype: 'namedCurve',\n\t\tvalue: oids[crv]\n\t}, 'der');\n\talgorithms[crv] = {\n\t\talgorithm:  [1, 2, 840, 10045, 2, 1],\n\t\tparameters: parameters[crv]\n\t};\n});\noids = null;\n\nfunction ecJwkToBuffer(jwk, opts) {\n\tif ('string' !== typeof jwk.crv) {\n\t\tthrow new TypeError('Expected \"jwk.crv\" to be a String');\n\t}\n\n\tvar hasD = 'string' === typeof jwk.d;\n\tvar xyTypes = hasD\n\t\t? ['undefined', 'string']\n\t\t: ['string'];\n\n\tif (-1 === xyTypes.indexOf(typeof jwk.x)) {\n\t\tthrow new TypeError('Expected \"jwk.x\" to be a String');\n\t}\n\n\tif (-1 === xyTypes.indexOf(typeof jwk.y)) {\n\t\tthrow new TypeError('Expected \"jwk.y\" to be a String');\n\t}\n\n\tif (opts.private && !hasD) {\n\t\tthrow new TypeError('Expected \"jwk.d\" to be a String');\n\t}\n\n\tvar curveName = curves[jwk.crv];\n\tif (!curveName) {\n\t\tthrow new Error('Unsupported curve \"' + jwk.crv + '\"');\n\t}\n\n\tvar curve = new EC(curveName);\n\n\tvar key = {};\n\n\tvar hasPub = jwk.x && jwk.y;\n\tif (hasPub) {\n\t\tkey.pub = {\n\t\t\tx: b64ToBn(jwk.x, false),\n\t\t\ty: b64ToBn(jwk.y, false)\n\t\t};\n\t}\n\n\tif (opts.private || !hasPub) {\n\t\tkey.priv = b64ToBn(jwk.d, true);\n\t}\n\n\tkey = curve.keyPair(key);\n\n\tvar keyValidation = key.validate();\n\tif (!keyValidation.result) {\n\t\tthrow new Error('Invalid key for curve: \"' + keyValidation.reason + '\"');\n\t}\n\n\tvar result = keyToPem(jwk.crv, key, opts);\n\n\treturn result;\n}\n\nfunction keyToPem(crv, key, opts) {\n\tvar compact = false;\n\tvar publicKey = key.getPublic(compact, 'hex');\n\tpublicKey = Buffer.from(publicKey, 'hex');\n\tpublicKey = {\n\t\tunused: 0,\n\t\tdata: publicKey\n\t};\n\n\tvar result;\n\tif (opts.private) {\n\t\tvar privateKey = key.getPrivate('hex');\n\t\tprivateKey = Buffer.from(privateKey, 'hex');\n\n\t\tresult = PrivateKeyInfo.encode({\n\t\t\tversion: 0,\n\t\t\tprivateKeyAlgorithm: algorithms[crv],\n\t\t\tprivateKey: ECPrivateKey.encode({\n\t\t\t\tversion: ecPrivkeyVer1,\n\t\t\t\tprivateKey: privateKey,\n\t\t\t\tparameters: parameters[crv],\n\t\t\t\tpublicKey: publicKey\n\t\t\t}, 'der')\n\t\t}, 'pem', {\n\t\t\tlabel: 'PRIVATE KEY'\n\t\t});\n\n\t\tprivateKey.fill(0);\n\t} else {\n\t\tresult = PublicKeyInfo.encode({\n\t\t\talgorithm: algorithms[crv],\n\t\t\tPublicKey: publicKey\n\t\t}, 'pem', {\n\t\t\tlabel: 'PUBLIC KEY'\n\t\t});\n\t}\n\n\t// This is in an if incase asn1.js adds a trailing \\n\n\t// istanbul ignore else\n\tif ('\\n' !== result.slice(-1)) {\n\t\tresult += '\\n';\n\t}\n\n\treturn result;\n}\n\nmodule.exports = ecJwkToBuffer;\n"]},"metadata":{},"sourceType":"script"}
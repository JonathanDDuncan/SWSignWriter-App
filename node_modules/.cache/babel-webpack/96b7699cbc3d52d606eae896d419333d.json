{"ast":null,"code":"import { __values } from \"tslib\";\nimport { API } from '@sentry/core';\nimport { Status } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\n/** Base Transport class implementation */\n\nvar BaseTransport =\n/** @class */\nfunction () {\n  function BaseTransport(options) {\n    this.options = options;\n    /** A simple buffer holding all requests. */\n\n    this._buffer = new PromiseBuffer(30);\n    /** Locks transport after receiving rate limits in a response */\n\n    this._rateLimits = {};\n    this._api = new API(this.options.dsn); // eslint-disable-next-line deprecation/deprecation\n\n    this.url = this._api.getStoreEndpointWithUrlEncodedAuth();\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.sendEvent = function (_) {\n    throw new SentryError('Transport Class has to implement `sendEvent` method');\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n\n\n  BaseTransport.prototype._handleResponse = function (_a) {\n    var requestType = _a.requestType,\n        response = _a.response,\n        headers = _a.headers,\n        resolve = _a.resolve,\n        reject = _a.reject;\n    var status = Status.fromHttpCode(response.status);\n    /**\n     * \"The name is case-insensitive.\"\n     * https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n     */\n\n    var limited = this._handleRateLimit(headers);\n\n    if (limited) logger.warn(\"Too many requests, backing off until: \" + this._disabledUntil(requestType));\n\n    if (status === Status.Success) {\n      resolve({\n        status: status\n      });\n      return;\n    }\n\n    reject(response);\n  };\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   */\n\n\n  BaseTransport.prototype._disabledUntil = function (category) {\n    return this._rateLimits[category] || this._rateLimits.all;\n  };\n  /**\n   * Checks if a category is rate limited\n   */\n\n\n  BaseTransport.prototype._isRateLimited = function (category) {\n    return this._disabledUntil(category) > new Date(Date.now());\n  };\n  /**\n   * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n   */\n\n\n  BaseTransport.prototype._handleRateLimit = function (headers) {\n    var e_1, _a, e_2, _b;\n\n    var now = Date.now();\n    var rlHeader = headers['x-sentry-rate-limits'];\n    var raHeader = headers['retry-after'];\n\n    if (rlHeader) {\n      try {\n        // rate limit headers are of the form\n        //     <header>,<header>,..\n        // where each <header> is of the form\n        //     <retry_after>: <categories>: <scope>: <reason_code>\n        // where\n        //     <retry_after> is a delay in ms\n        //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n        //         <category>;<category>;...\n        //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n        //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n        for (var _c = __values(rlHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var limit = _d.value;\n          var parameters = limit.split(':', 2);\n          var headerDelay = parseInt(parameters[0], 10);\n          var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n\n          try {\n            for (var _e = (e_2 = void 0, __values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var category = _f.value;\n              this._rateLimits[category || 'all'] = new Date(now + delay);\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return true;\n    } else if (raHeader) {\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, raHeader));\n      return true;\n    }\n\n    return false;\n  };\n\n  return BaseTransport;\n}();\n\nexport { BaseTransport }; //# sourceMappingURL=base.js.map","map":{"version":3,"sources":["C:/Users/Fernando Martinez/Documents/Programacion/SignWriter/Frontend JD/node_modules/@sentry/browser/esm/transports/base.js"],"names":["__values","API","Status","logger","parseRetryAfterHeader","PromiseBuffer","SentryError","BaseTransport","options","_buffer","_rateLimits","_api","dsn","url","getStoreEndpointWithUrlEncodedAuth","prototype","sendEvent","_","close","timeout","drain","_handleResponse","_a","requestType","response","headers","resolve","reject","status","fromHttpCode","limited","_handleRateLimit","warn","_disabledUntil","Success","category","all","_isRateLimited","Date","now","e_1","e_2","_b","rlHeader","raHeader","_c","trim","split","_d","next","done","limit","value","parameters","headerDelay","parseInt","delay","isNaN","_e","_f","e_2_1","error","return","call","e_1_1"],"mappings":"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","sourcesContent":["import { __values } from \"tslib\";\nimport { API } from '@sentry/core';\nimport { Status, } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\n/** Base Transport class implementation */\nvar BaseTransport = /** @class */ (function () {\n    function BaseTransport(options) {\n        this.options = options;\n        /** A simple buffer holding all requests. */\n        this._buffer = new PromiseBuffer(30);\n        /** Locks transport after receiving rate limits in a response */\n        this._rateLimits = {};\n        this._api = new API(this.options.dsn);\n        // eslint-disable-next-line deprecation/deprecation\n        this.url = this._api.getStoreEndpointWithUrlEncodedAuth();\n    }\n    /**\n     * @inheritDoc\n     */\n    BaseTransport.prototype.sendEvent = function (_) {\n        throw new SentryError('Transport Class has to implement `sendEvent` method');\n    };\n    /**\n     * @inheritDoc\n     */\n    BaseTransport.prototype.close = function (timeout) {\n        return this._buffer.drain(timeout);\n    };\n    /**\n     * Handle Sentry repsonse for promise-based transports.\n     */\n    BaseTransport.prototype._handleResponse = function (_a) {\n        var requestType = _a.requestType, response = _a.response, headers = _a.headers, resolve = _a.resolve, reject = _a.reject;\n        var status = Status.fromHttpCode(response.status);\n        /**\n         * \"The name is case-insensitive.\"\n         * https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n         */\n        var limited = this._handleRateLimit(headers);\n        if (limited)\n            logger.warn(\"Too many requests, backing off until: \" + this._disabledUntil(requestType));\n        if (status === Status.Success) {\n            resolve({ status: status });\n            return;\n        }\n        reject(response);\n    };\n    /**\n     * Gets the time that given category is disabled until for rate limiting\n     */\n    BaseTransport.prototype._disabledUntil = function (category) {\n        return this._rateLimits[category] || this._rateLimits.all;\n    };\n    /**\n     * Checks if a category is rate limited\n     */\n    BaseTransport.prototype._isRateLimited = function (category) {\n        return this._disabledUntil(category) > new Date(Date.now());\n    };\n    /**\n     * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n     */\n    BaseTransport.prototype._handleRateLimit = function (headers) {\n        var e_1, _a, e_2, _b;\n        var now = Date.now();\n        var rlHeader = headers['x-sentry-rate-limits'];\n        var raHeader = headers['retry-after'];\n        if (rlHeader) {\n            try {\n                // rate limit headers are of the form\n                //     <header>,<header>,..\n                // where each <header> is of the form\n                //     <retry_after>: <categories>: <scope>: <reason_code>\n                // where\n                //     <retry_after> is a delay in ms\n                //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n                //         <category>;<category>;...\n                //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n                //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n                for (var _c = __values(rlHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var limit = _d.value;\n                    var parameters = limit.split(':', 2);\n                    var headerDelay = parseInt(parameters[0], 10);\n                    var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n                    try {\n                        for (var _e = (e_2 = void 0, __values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {\n                            var category = _f.value;\n                            this._rateLimits[category || 'all'] = new Date(now + delay);\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return true;\n        }\n        else if (raHeader) {\n            this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, raHeader));\n            return true;\n        }\n        return false;\n    };\n    return BaseTransport;\n}());\nexport { BaseTransport };\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"module"}
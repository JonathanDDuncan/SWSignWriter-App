{"ast":null,"code":"var parse = require('url-parse');\n\nvar auth0 = require('auth0-js');\n\nvar getAgent = require('./agent');\n\nvar crypto = require('./crypto');\n\nvar session = require('./session');\n\nvar getOS = require('./utils').getOS;\n\nvar version = require('./version').raw;\n\nvar generateProofKey = crypto.generateProofKey;\nvar generateState = crypto.generateState;\nvar closingDelayMs = 1000;\nsession.clean();\nvar telemetry = {\n  name: 'auth0-cordova',\n  version: version,\n  env: {\n    'auth0.js': auth0.version,\n    os: getOS()\n  }\n};\n/**\n * Creates a new Cordova client to handle AuthN/AuthZ with OAuth and OS browser.\n * @constructor\n * @param {Object} options\n * @param {String} options.domain your Auth0 domain\n * @param {String} options.clientId your Auth0 client identifier obtained when creating the client in the Auth0 Dashboard\n * @see {@link https://auth0.com/docs/api/authentication}\n */\n\nfunction CordovaAuth(options) {\n  this.clientId = options.clientId;\n  this.domain = options.domain;\n  this.redirectUri = options.packageIdentifier + '://' + options.domain + '/cordova/' + options.packageIdentifier + '/callback';\n  this.auth0 = new auth0.WebAuth({\n    clientID: this.clientId,\n    domain: this.domain\n  });\n  this.client = new auth0.Authentication(this.auth0, {\n    clientID: this.clientId,\n    domain: this.domain,\n    _telemetryInfo: telemetry\n  });\n}\n/**\n * @callback authorizeCallback\n * @param {Error} [err] error returned by Auth0 with the reason of the Auth failure\n * @param {Object} [result] result of the Auth request\n * @param {String} [result.accessToken] token that allows access to the specified resource server (identified by the audience parameter or by default Auth0's /userinfo endpoint)\n * @param {Number} [result.expiresIn] number of seconds until the access token expires\n * @param {String} [result.idToken] token that identifies the user\n * @param {String} [result.refreshToken] token that can be used to get new access tokens from Auth0. Note that not all clients can request them or the resource server might not allow them.\n */\n\n/**\n * Opens the OS browser and redirects to `{domain}/authorize` url in order to initialize a new authN/authZ transaction\n *\n * @method authorize\n * @param {Object} parameters\n * @param {String} [parameters.state] value used to mitigate XSRF attacks. {@link https://auth0.com/docs/protocols/oauth2/oauth-state}\n * @param {String} [parameters.nonce] value used to mitigate replay attacks when using Implicit Grant. {@link https://auth0.com/docs/api-auth/tutorials/nonce}\n * @param {String} [parameters.scope] scopes to be requested during Auth. e.g. `openid email`\n * @param {String} [parameters.audience] identifier of the resource server who will consume the access token issued after Auth\n * @param {authorizeCallback} callback\n * @see {@link https://auth0.com/docs/api/authentication#authorize-client}\n * @see {@link https://auth0.com/docs/api/authentication#social}\n */\n\n\nCordovaAuth.prototype.authorize = function (parameters, callback) {\n  if (!callback || typeof callback !== 'function') {\n    throw new Error('callback not specified or is not a function');\n  }\n\n  var self = this;\n  getAgent(function (err, agent) {\n    if (err) {\n      return callback(err);\n    }\n\n    var keys = generateProofKey();\n    var client = self.client;\n    var redirectUri = self.redirectUri;\n    var requestState = parameters.state || generateState();\n    parameters.state = requestState;\n    var params = Object.assign({}, parameters, {\n      code_challenge_method: 'S256',\n      responseType: 'code',\n      redirectUri: redirectUri,\n      code_challenge: keys.codeChallenge\n    });\n    var url = client.buildAuthorizeUrl(params);\n    session.start(function (sessionError, redirectUrl) {\n      if (sessionError != null) {\n        callback(sessionError);\n        return true;\n      }\n\n      if (redirectUrl.indexOf(redirectUri) === -1) {\n        return false;\n      }\n\n      if (!redirectUrl || typeof redirectUrl !== 'string') {\n        callback(new Error('url must be a string'));\n        return true;\n      }\n\n      var response = parse(redirectUrl, true).query;\n\n      if (response.error) {\n        callback(new Error(response.error_description || response.error));\n        return true;\n      }\n\n      var responseState = response.state;\n\n      if (responseState !== requestState) {\n        callback(new Error('Response state does not match expected state'));\n        return true;\n      }\n\n      var code = response.code;\n      var verifier = keys.codeVerifier;\n      agent.close();\n      client.oauthToken({\n        code_verifier: verifier,\n        grantType: 'authorization_code',\n        redirectUri: redirectUri,\n        code: code\n      }, function (exchangeError, exchangeResult) {\n        if (exchangeError) {\n          return callback(exchangeError);\n        }\n\n        return callback(null, exchangeResult);\n      });\n      return true;\n    });\n    agent.open(url, function (error, result) {\n      if (error != null) {\n        session.clean();\n        return callback(error);\n      }\n\n      if (result.event === 'closed') {\n        var handleClose = function handleClose() {\n          if (session.isClosing) {\n            session.clean();\n            return callback(new Error('user canceled'));\n          }\n        };\n\n        session.closing();\n\n        if (getOS() === 'ios') {\n          handleClose();\n        } else {\n          setTimeout(handleClose, closingDelayMs);\n          return;\n        }\n      }\n\n      if (result.event !== 'loaded') {\n        // Ignore any other events.\n        return;\n      }\n    });\n  });\n};\n/**\n * Handler that must be called with the redirect url the browser tries to open after the OAuth flow is done.\n * To listen to that event, using cordova-plugin-customurlscheme, you need to register a callback in the method `window.handleOpenURL`\n * ```\n * var Auth0Cordova = require('@auth0/cordova');\n * window.handleOpenURL = Auth0Cordova.onRedirectUri(url);\n * ```\n *\n * @method onRedirectUri\n * @param {String} url with a custom scheme relied to the application\n */\n\n\nCordovaAuth.onRedirectUri = function (url) {\n  // If we are running in UIWebView we need to wait\n  if (window.webkit && window.webkit.messageHandlers) {\n    return session.onRedirectUri(url);\n  }\n\n  return setTimeout(function () {\n    session.onRedirectUri(url);\n  }, 4);\n};\n\nCordovaAuth.version = version;\nmodule.exports = CordovaAuth;","map":{"version":3,"sources":["C:/Users/Fernando Martinez/Documents/Programacion/SignWriter/Frontend JD/node_modules/@auth0/cordova/src/index.js"],"names":["parse","require","auth0","getAgent","crypto","session","getOS","version","raw","generateProofKey","generateState","closingDelayMs","clean","telemetry","name","env","os","CordovaAuth","options","clientId","domain","redirectUri","packageIdentifier","WebAuth","clientID","client","Authentication","_telemetryInfo","prototype","authorize","parameters","callback","Error","self","err","agent","keys","requestState","state","params","Object","assign","code_challenge_method","responseType","code_challenge","codeChallenge","url","buildAuthorizeUrl","start","sessionError","redirectUrl","indexOf","response","query","error","error_description","responseState","code","verifier","codeVerifier","close","oauthToken","code_verifier","grantType","exchangeError","exchangeResult","open","result","event","handleClose","isClosing","closing","setTimeout","onRedirectUri","window","webkit","messageHandlers","module","exports"],"mappings":"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","sourcesContent":["var parse = require('url-parse');\nvar auth0 = require('auth0-js');\nvar getAgent = require('./agent');\nvar crypto = require('./crypto');\nvar session = require('./session');\nvar getOS = require('./utils').getOS;\nvar version = require('./version').raw;\n\nvar generateProofKey = crypto.generateProofKey;\nvar generateState = crypto.generateState;\nvar closingDelayMs = 1000;\n\nsession.clean();\n\nvar telemetry = {\n  name: 'auth0-cordova',\n  version: version,\n  env: {\n    'auth0.js': auth0.version,\n    os: getOS()\n  }\n};\n\n/**\n * Creates a new Cordova client to handle AuthN/AuthZ with OAuth and OS browser.\n * @constructor\n * @param {Object} options\n * @param {String} options.domain your Auth0 domain\n * @param {String} options.clientId your Auth0 client identifier obtained when creating the client in the Auth0 Dashboard\n * @see {@link https://auth0.com/docs/api/authentication}\n */\nfunction CordovaAuth(options) {\n  this.clientId = options.clientId;\n  this.domain = options.domain;\n  this.redirectUri = options.packageIdentifier + '://' + options.domain + '/cordova/' + options.packageIdentifier + '/callback';\n  this.auth0 = new auth0.WebAuth({\n    clientID: this.clientId,\n    domain: this.domain\n  });\n  this.client = new auth0.Authentication(this.auth0, {\n    clientID: this.clientId,\n    domain: this.domain,\n    _telemetryInfo: telemetry\n  });\n}\n\n/**\n * @callback authorizeCallback\n * @param {Error} [err] error returned by Auth0 with the reason of the Auth failure\n * @param {Object} [result] result of the Auth request\n * @param {String} [result.accessToken] token that allows access to the specified resource server (identified by the audience parameter or by default Auth0's /userinfo endpoint)\n * @param {Number} [result.expiresIn] number of seconds until the access token expires\n * @param {String} [result.idToken] token that identifies the user\n * @param {String} [result.refreshToken] token that can be used to get new access tokens from Auth0. Note that not all clients can request them or the resource server might not allow them.\n */\n\n/**\n * Opens the OS browser and redirects to `{domain}/authorize` url in order to initialize a new authN/authZ transaction\n *\n * @method authorize\n * @param {Object} parameters\n * @param {String} [parameters.state] value used to mitigate XSRF attacks. {@link https://auth0.com/docs/protocols/oauth2/oauth-state}\n * @param {String} [parameters.nonce] value used to mitigate replay attacks when using Implicit Grant. {@link https://auth0.com/docs/api-auth/tutorials/nonce}\n * @param {String} [parameters.scope] scopes to be requested during Auth. e.g. `openid email`\n * @param {String} [parameters.audience] identifier of the resource server who will consume the access token issued after Auth\n * @param {authorizeCallback} callback\n * @see {@link https://auth0.com/docs/api/authentication#authorize-client}\n * @see {@link https://auth0.com/docs/api/authentication#social}\n */\nCordovaAuth.prototype.authorize = function (parameters, callback) {\n  if (!callback || typeof callback !== 'function') {\n    throw new Error('callback not specified or is not a function');\n  }\n\n  var self = this;\n\n  getAgent(function (err, agent) {\n    if (err) {\n      return callback(err);\n    }\n\n    var keys = generateProofKey();\n    var client = self.client;\n    var redirectUri = self.redirectUri;\n    var requestState = parameters.state || generateState();\n\n    parameters.state = requestState;\n\n    var params = Object.assign({}, parameters, {\n      code_challenge_method: 'S256',\n      responseType: 'code',\n      redirectUri: redirectUri,\n      code_challenge: keys.codeChallenge\n    });\n\n    var url = client.buildAuthorizeUrl(params);\n\n    session.start(function (sessionError, redirectUrl) {\n      if (sessionError != null) {\n        callback(sessionError);\n        return true;\n      }\n      if (redirectUrl.indexOf(redirectUri) === -1) {\n        return false;\n      }\n      if (!redirectUrl || typeof redirectUrl !== 'string') {\n        callback(new Error('url must be a string'));\n        return true;\n      }\n      var response = parse(redirectUrl, true).query;\n      if (response.error) {\n        callback(new Error(response.error_description || response.error));\n        return true;\n      }\n      var responseState = response.state;\n      if (responseState !== requestState) {\n        callback(new Error('Response state does not match expected state'));\n        return true;\n      }\n      var code = response.code;\n      var verifier = keys.codeVerifier;\n      agent.close();\n\n      client.oauthToken({\n        code_verifier: verifier,\n        grantType: 'authorization_code',\n        redirectUri: redirectUri,\n        code: code\n      }, function (exchangeError, exchangeResult) {\n        if (exchangeError) {\n          return callback(exchangeError);\n        }\n        return callback(null, exchangeResult);\n      });\n\n      return true;\n    });\n\n    agent.open(url, function (error, result) {\n      if (error != null) {\n        session.clean();\n        return callback(error);\n      }\n\n      if (result.event === 'closed') {\n        var handleClose = function () {\n          if (session.isClosing) {\n            session.clean();\n            return callback(new Error('user canceled'));\n          }\n        };\n\n        session.closing();\n        if (getOS() === 'ios') {\n          handleClose();\n        } else {\n          setTimeout(handleClose, closingDelayMs);\n          return;\n        }\n      }\n\n      if (result.event !== 'loaded') {\n        // Ignore any other events.\n        return;\n      }\n    });\n  });\n};\n\n/**\n * Handler that must be called with the redirect url the browser tries to open after the OAuth flow is done.\n * To listen to that event, using cordova-plugin-customurlscheme, you need to register a callback in the method `window.handleOpenURL`\n * ```\n * var Auth0Cordova = require('@auth0/cordova');\n * window.handleOpenURL = Auth0Cordova.onRedirectUri(url);\n * ```\n *\n * @method onRedirectUri\n * @param {String} url with a custom scheme relied to the application\n */\nCordovaAuth.onRedirectUri = function (url) {\n  // If we are running in UIWebView we need to wait\n  if (window.webkit && window.webkit.messageHandlers) {\n    return session.onRedirectUri(url);\n  }\n\n  return setTimeout(function () {\n    session.onRedirectUri(url);\n  }, 4);\n};\n\nCordovaAuth.version = version;\n\nmodule.exports = CordovaAuth;\n"]},"metadata":{},"sourceType":"script"}
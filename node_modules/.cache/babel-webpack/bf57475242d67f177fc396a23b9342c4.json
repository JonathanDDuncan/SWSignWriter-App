{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Fernando Martinez/Documents/Programacion/SignWriter/Frontend JD/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { NormalizationService } from './normalization.service';\nimport { Storage } from '@ionic/storage';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ionic/storage\";\nimport * as i2 from \"./normalization.service\";\nexport var Lane;\n\n(function (Lane) {\n  Lane[Lane[\"Left\"] = 0] = \"Left\";\n  Lane[Lane[\"Middle\"] = 1] = \"Middle\";\n  Lane[Lane[\"Right\"] = 2] = \"Right\";\n})(Lane || (Lane = {}));\n\nexport class SignsLookupService {\n  constructor(storage, normalize) {\n    this.storage = storage;\n    this.normalize = normalize;\n  }\n\n  ngOnInit() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this.loadSigns();\n    })();\n  }\n\n  loadSigns() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const self = _this2;\n      _this2.entrylist = [];\n      const puddles = yield _this2.storage.get('puddles');\n\n      if (puddles) {\n        puddles.forEach( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (puddle) {\n            const puddleentries = yield _this2.storage.get(puddle);\n            puddleentries.entries.forEach(entry => {\n              entry.glosses.forEach(gloss => {\n                _this2.entrylist.push({\n                  normalized: _this2.normalize.normalizeForSearch(gloss),\n                  gloss: gloss,\n                  key: entry.key,\n                  fsw: entry.fsw\n                });\n              });\n            });\n            _this2.words = _this2.getAvailableWords();\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      }\n    })();\n  }\n\n  search(text) {\n    let result = [];\n    const substring = [];\n    let count = 0;\n    let substringcount = 0;\n    const text1 = text ? text.trim() : '';\n    const searchtext = this.normalize.normalizeForSearch(text1);\n\n    if (this.entrylist) {\n      for (let i = 0; i < this.entrylist.length; i++) {\n        const entry = this.entrylist[i];\n\n        if (searchtext.length > 2) {\n          if (entry.normalized.startsWith(searchtext)) {\n            result.push(entry);\n            count++;\n          } else if (entry.normalized.includes(searchtext)) {\n            substring.push(entry);\n            substringcount++;\n          }\n        } else if (searchtext.length > 0) {\n          if (entry.normalized === searchtext || entry.normalized.startsWith(searchtext + '-')) {\n            result.push(entry);\n            count++;\n          }\n        }\n      }\n    } // show substring matches if no start of line found\n\n\n    if (count === 0 && substringcount > 0) {\n      result = substring;\n    }\n\n    let finalresult;\n    const unique = this.arrayUnique(result);\n\n    if (unique.length > 25) {\n      finalresult = unique.filter(x => x.gloss.length === text.length);\n    } else {\n      finalresult = unique;\n    }\n\n    finalresult.sort(function (a, b) {\n      if (a.gloss > b.gloss) {\n        return 1;\n      }\n\n      if (a.gloss < b.gloss) {\n        return -1;\n      } // a must be equal to b\n\n\n      return 0;\n    });\n    return finalresult;\n  }\n\n  arrayUnique(arr) {\n    const existingkeys = [];\n    const keep = [];\n    arr.forEach(element => {\n      if (!existingkeys.includes(element.key)) {\n        existingkeys.push(element.key);\n        keep.push(element);\n      }\n    });\n    return keep;\n  }\n\n  getsign(key) {\n    return this.entrylist.find(entry => entry.key === key);\n  }\n\n  getAvailableWords() {\n    const uniqueWords = [];\n    const map = new Map();\n\n    for (let i = 0; i < this.entrylist.length; i++) {\n      const entry = this.entrylist[i];\n      const gloss = entry.gloss;\n\n      if (!map.has(gloss)) {\n        map.set(gloss, true);\n        uniqueWords.push({\n          gloss,\n          normalized: entry.normalized\n        });\n      }\n    }\n\n    const sorted = uniqueWords.sort((x, y) => {\n      if (x.gloss < y.gloss) {\n        return -1;\n      } else if (x > y) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n    return sorted;\n  } // Available words\n\n\n  showAvailableWords(text) {\n    const words = text.split(' ');\n    const keyword = words.length > 0 ? words[words.length - 1] : '';\n    return this.getResults(this.words, keyword);\n  }\n\n  getResults(availableWords, keyword) {\n    if (availableWords && keyword && keyword !== '') {\n      const maxResults = 12;\n      const startsWith = [];\n      const contains = [];\n      const lwrCaseKeyword = keyword.toLowerCase();\n      let i = 0;\n\n      for (const element of availableWords) {\n        if (element && element.gloss && element.gloss.toLowerCase().startsWith(lwrCaseKeyword)) {\n          startsWith.push(element);\n          i++;\n        } else if (element && element.normalized && element.normalized.toLowerCase().startsWith(lwrCaseKeyword)) {\n          startsWith.push(element);\n          i++;\n        } else if (element && element.gloss && element.gloss.toLowerCase().indexOf(lwrCaseKeyword) !== -1) {\n          contains.push(element);\n        } else if (element && element.normalized && element.normalized.toLowerCase().indexOf(lwrCaseKeyword) !== -1) {\n          contains.push(element);\n        }\n\n        if (i >= maxResults) {\n          break;\n        }\n      }\n\n      let result = [];\n      result = startsWith.slice(0, maxResults);\n\n      if (result.length < maxResults) {\n        result.concat(contains.slice(0, maxResults - result.length));\n      }\n\n      return result;\n    } else {\n      return [];\n    }\n  }\n\n}\n\nSignsLookupService.ɵfac = function SignsLookupService_Factory(t) {\n  return new (t || SignsLookupService)(i0.ɵɵinject(i1.Storage), i0.ɵɵinject(i2.NormalizationService));\n};\n\nSignsLookupService.ɵprov = i0.ɵɵdefineInjectable({\n  token: SignsLookupService,\n  factory: SignsLookupService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["C:\\Users\\Fernando Martinez\\Documents\\Programacion\\SignWriter\\Frontend JD\\src\\app\\signs-lookup.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable, OnInit } from '@angular/core';\r\nimport { NormalizationService } from './normalization.service';\r\nimport { Storage } from '@ionic/storage';\r\n\r\nexport interface Sign {\r\n  sign: string;\r\n  key: string;\r\n  fsw: string;\r\n  gloss: string;\r\n  normalized: string;\r\n}\r\n\r\nexport interface FoundSign {\r\n  sign: Sign;\r\n  text: string;\r\n  id: string;\r\n  svg: string;\r\n  totalmatches: number;\r\n  color: string;\r\n  lane: Lane;\r\n}\r\n\r\nexport enum Lane {\r\n  Left,\r\n  Middle,\r\n  Right\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class SignsLookupService implements OnInit {\r\n  private entrylist: any[];\r\n  private words: { gloss: string, normalized: string }[];\r\n\r\n constructor(\r\n    private storage: Storage,\r\n    private normalize: NormalizationService\r\n  ) {}\r\n\r\n  async ngOnInit(): Promise<void> {\r\n    await this.loadSigns();\r\n  }\r\n\r\n  async loadSigns() {\r\n    const self = this;\r\n    this.entrylist = [];\r\n    const puddles = await this.storage.get('puddles');\r\n\r\n      if (puddles) {\r\n        puddles.forEach(async puddle => {\r\n          const puddleentries = await this.storage.get(puddle);\r\n\r\n          puddleentries.entries.forEach(entry => {\r\n              entry.glosses.forEach(gloss => {\r\n                this.entrylist.push({\r\n                  normalized: this.normalize.normalizeForSearch(gloss),\r\n                  gloss: gloss,\r\n                  key: entry.key,\r\n                  fsw: entry.fsw\r\n                });\r\n              });\r\n            });\r\n            this.words = this.getAvailableWords();\r\n          });\r\n      }\r\n  }\r\n\r\n  search(text: string): Sign[] {\r\n    let result = [];\r\n    const substring = [];\r\n    let count = 0;\r\n    let substringcount = 0;\r\n    const text1 = text ? text.trim() : '';\r\n    const searchtext = this.normalize.normalizeForSearch(text1);\r\n    if (this.entrylist) {\r\n      for (let i = 0; i < this.entrylist.length; i++) {\r\n        const entry = this.entrylist[i];\r\n\r\n        if (searchtext.length > 2) {\r\n          if (entry.normalized.startsWith(searchtext)) {\r\n            result.push(entry);\r\n            count++;\r\n          } else if (entry.normalized.includes(searchtext)) {\r\n            substring.push(entry);\r\n            substringcount++;\r\n          }\r\n        } else if (searchtext.length > 0) {\r\n          if (entry.normalized === searchtext || entry.normalized.startsWith(searchtext + '-')) {\r\n            result.push(entry);\r\n            count++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // show substring matches if no start of line found\r\n    if (count === 0 && substringcount > 0) {\r\n      result = substring;\r\n    }\r\n    let finalresult: Sign[];\r\n    const unique = this.arrayUnique(result);\r\n\r\n    if (unique.length > 25) {\r\n      finalresult = unique.filter(x => x.gloss.length === text.length);\r\n    } else {\r\n      finalresult = unique;\r\n    }\r\n    finalresult.sort(function (a, b) {\r\n      if (a.gloss > b.gloss) {\r\n        return 1;\r\n      }\r\n      if (a.gloss < b.gloss) {\r\n        return -1;\r\n      }\r\n      // a must be equal to b\r\n      return 0;\r\n    });\r\n    return finalresult;\r\n  }\r\n\r\n  private arrayUnique(arr: Sign[]): Sign[] {\r\n    const existingkeys = [];\r\n    const keep: Sign[] = [];\r\n    arr.forEach(element => {\r\n      if (!existingkeys.includes(element.key)) {\r\n        existingkeys.push(element.key);\r\n        keep.push(element);\r\n      }\r\n    });\r\n    return keep;\r\n  }\r\n\r\n  getsign(key: string) {\r\n    return this.entrylist.find(entry => entry.key === key);\r\n  }\r\n\r\n  getAvailableWords(): { gloss: string, normalized: string }[] {\r\n    const uniqueWords = [];\r\n    const map = new Map();\r\n    for (let i = 0; i < this.entrylist.length; i++) {\r\n      const entry = this.entrylist[i];\r\n      const gloss = entry.gloss;\r\n      if (!map.has(gloss)) {\r\n        map.set(gloss, true);\r\n        uniqueWords.push({ gloss, normalized: entry.normalized });\r\n      }\r\n    }\r\n\r\n    const sorted = uniqueWords.sort((x: { gloss: string, normalized: string }, y: { gloss: string, normalized: string }) => {\r\n      if (x.gloss < y.gloss) {\r\n        return -1;\r\n      } else if (x > y) {\r\n        return 1;\r\n      } else {\r\n        return 0;\r\n      }\r\n    });\r\n    return sorted;\r\n  }\r\n\r\n  // Available words\r\n  showAvailableWords(text: string) {\r\n    const words = text.split(' ');\r\n\r\n    const keyword = words.length > 0 ? words[words.length - 1] : '';\r\n    return this.getResults(this.words, keyword);\r\n  }\r\n\r\n  getResults(availableWords: { gloss: string, normalized: string }[], keyword: string) {\r\n    if (availableWords && keyword && keyword !== '') {\r\n      const maxResults = 12;\r\n      const startsWith = [];\r\n      const contains = [];\r\n      const lwrCaseKeyword = keyword.toLowerCase();\r\n      let i = 0;\r\n      for (const element of availableWords) {\r\n        if (element && element.gloss && element.gloss.toLowerCase().startsWith(lwrCaseKeyword)) {\r\n          startsWith.push(element);\r\n          i++;\r\n        } else if (element && element.normalized && element.normalized.toLowerCase().startsWith(lwrCaseKeyword)) {\r\n          startsWith.push(element);\r\n          i++;\r\n        } else if (element && element.gloss && element.gloss.toLowerCase().indexOf(lwrCaseKeyword) !== -1) {\r\n          contains.push(element);\r\n        } else if (element && element.normalized && element.normalized.toLowerCase().indexOf(lwrCaseKeyword) !== -1) {\r\n          contains.push(element);\r\n        }\r\n\r\n        if (i >= maxResults) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      let result = [];\r\n      result = startsWith.slice(0, maxResults);\r\n      if (result.length < maxResults) {\r\n        result.concat(contains.slice(0, maxResults - result.length));\r\n      }\r\n\r\n      return result;\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, isDOMError, isDOMException, isError, isErrorEvent, isEvent, isPlainObject, SyncPromise } from '@sentry/utils';\nimport { eventFromPlainObject, eventFromStacktrace, prepareFramesForEvent } from './parsers';\nimport { computeStackTrace } from './tracekit';\n/**\n * Builds and Event from a Exception\n * @hidden\n */\n\nexport function eventFromException(options, exception, hint) {\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromUnknownInput(exception, syntheticException, {\n    attachStacktrace: options.attachStacktrace\n  });\n  addExceptionMechanism(event, {\n    handled: true,\n    type: 'generic'\n  });\n  event.level = Severity.Error;\n\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n\n  return SyncPromise.resolve(event);\n}\n/**\n * Builds and Event from a Message\n * @hidden\n */\n\nexport function eventFromMessage(options, message, level, hint) {\n  if (level === void 0) {\n    level = Severity.Info;\n  }\n\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromString(message, syntheticException, {\n    attachStacktrace: options.attachStacktrace\n  });\n  event.level = level;\n\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n\n  return SyncPromise.resolve(event);\n}\n/**\n * @hidden\n */\n\nexport function eventFromUnknownInput(exception, syntheticException, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var event;\n\n  if (isErrorEvent(exception) && exception.error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    var errorEvent = exception; // eslint-disable-next-line no-param-reassign\n\n    exception = errorEvent.error;\n    event = eventFromStacktrace(computeStackTrace(exception));\n    return event;\n  }\n\n  if (isDOMError(exception) || isDOMException(exception)) {\n    // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)\n    // then we just extract the name, code, and message, as they don't provide anything else\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n    var domException = exception;\n    var name_1 = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n    var message = domException.message ? name_1 + \": \" + domException.message : name_1;\n    event = eventFromString(message, syntheticException, options);\n    addExceptionTypeValue(event, message);\n\n    if ('code' in domException) {\n      event.tags = __assign(__assign({}, event.tags), {\n        'DOMException.code': \"\" + domException.code\n      });\n    }\n\n    return event;\n  }\n\n  if (isError(exception)) {\n    // we have a real Error object, do nothing\n    event = eventFromStacktrace(computeStackTrace(exception));\n    return event;\n  }\n\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it is plain Object or Event, serialize it manually and extract options\n    // This will allow us to group events based on top-level keys\n    // which is much better than creating new group when any key/value change\n    var objectException = exception;\n    event = eventFromPlainObject(objectException, syntheticException, options.rejection);\n    addExceptionMechanism(event, {\n      synthetic: true\n    });\n    return event;\n  } // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n\n\n  event = eventFromString(exception, syntheticException, options);\n  addExceptionTypeValue(event, \"\" + exception, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true\n  });\n  return event;\n}\n/**\n * @hidden\n */\n\nexport function eventFromString(input, syntheticException, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var event = {\n    message: input\n  };\n\n  if (options.attachStacktrace && syntheticException) {\n    var stacktrace = computeStackTrace(syntheticException);\n    var frames_1 = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames: frames_1\n    };\n  }\n\n  return event;\n} //# sourceMappingURL=eventbuilder.js.map","map":{"version":3,"sources":["C:/Users/Fernando Martinez/Documents/Programacion/SignWriter/Frontend JD/node_modules/@sentry/browser/esm/eventbuilder.js"],"names":["__assign","Severity","addExceptionMechanism","addExceptionTypeValue","isDOMError","isDOMException","isError","isErrorEvent","isEvent","isPlainObject","SyncPromise","eventFromPlainObject","eventFromStacktrace","prepareFramesForEvent","computeStackTrace","eventFromException","options","exception","hint","syntheticException","undefined","event","eventFromUnknownInput","attachStacktrace","handled","type","level","Error","event_id","resolve","eventFromMessage","message","Info","eventFromString","error","errorEvent","domException","name_1","name","tags","code","objectException","rejection","synthetic","input","stacktrace","frames_1","stack","frames"],"mappings":"AAAA,SAASA,QAAT,QAAyB,OAAzB;AACA,SAASC,QAAT,QAAyB,eAAzB;AACA,SAASC,qBAAT,EAAgCC,qBAAhC,EAAuDC,UAAvD,EAAmEC,cAAnE,EAAmFC,OAAnF,EAA4FC,YAA5F,EAA0GC,OAA1G,EAAmHC,aAAnH,EAAkIC,WAAlI,QAAsJ,eAAtJ;AACA,SAASC,oBAAT,EAA+BC,mBAA/B,EAAoDC,qBAApD,QAAiF,WAAjF;AACA,SAASC,iBAAT,QAAkC,YAAlC;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,kBAAT,CAA4BC,OAA5B,EAAqCC,SAArC,EAAgDC,IAAhD,EAAsD;AACzD,MAAIC,kBAAkB,GAAID,IAAI,IAAIA,IAAI,CAACC,kBAAd,IAAqCC,SAA9D;AACA,MAAIC,KAAK,GAAGC,qBAAqB,CAACL,SAAD,EAAYE,kBAAZ,EAAgC;AAC7DI,IAAAA,gBAAgB,EAAEP,OAAO,CAACO;AADmC,GAAhC,CAAjC;AAGArB,EAAAA,qBAAqB,CAACmB,KAAD,EAAQ;AACzBG,IAAAA,OAAO,EAAE,IADgB;AAEzBC,IAAAA,IAAI,EAAE;AAFmB,GAAR,CAArB;AAIAJ,EAAAA,KAAK,CAACK,KAAN,GAAczB,QAAQ,CAAC0B,KAAvB;;AACA,MAAIT,IAAI,IAAIA,IAAI,CAACU,QAAjB,EAA2B;AACvBP,IAAAA,KAAK,CAACO,QAAN,GAAiBV,IAAI,CAACU,QAAtB;AACH;;AACD,SAAOlB,WAAW,CAACmB,OAAZ,CAAoBR,KAApB,CAAP;AACH;AACD;AACA;AACA;AACA;;AACA,OAAO,SAASS,gBAAT,CAA0Bd,OAA1B,EAAmCe,OAAnC,EAA4CL,KAA5C,EAAmDR,IAAnD,EAAyD;AAC5D,MAAIQ,KAAK,KAAK,KAAK,CAAnB,EAAsB;AAAEA,IAAAA,KAAK,GAAGzB,QAAQ,CAAC+B,IAAjB;AAAwB;;AAChD,MAAIb,kBAAkB,GAAID,IAAI,IAAIA,IAAI,CAACC,kBAAd,IAAqCC,SAA9D;AACA,MAAIC,KAAK,GAAGY,eAAe,CAACF,OAAD,EAAUZ,kBAAV,EAA8B;AACrDI,IAAAA,gBAAgB,EAAEP,OAAO,CAACO;AAD2B,GAA9B,CAA3B;AAGAF,EAAAA,KAAK,CAACK,KAAN,GAAcA,KAAd;;AACA,MAAIR,IAAI,IAAIA,IAAI,CAACU,QAAjB,EAA2B;AACvBP,IAAAA,KAAK,CAACO,QAAN,GAAiBV,IAAI,CAACU,QAAtB;AACH;;AACD,SAAOlB,WAAW,CAACmB,OAAZ,CAAoBR,KAApB,CAAP;AACH;AACD;AACA;AACA;;AACA,OAAO,SAASC,qBAAT,CAA+BL,SAA/B,EAA0CE,kBAA1C,EAA8DH,OAA9D,EAAuE;AAC1E,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,EAAV;AAAe;;AACzC,MAAIK,KAAJ;;AACA,MAAId,YAAY,CAACU,SAAD,CAAZ,IAA2BA,SAAS,CAACiB,KAAzC,EAAgD;AAC5C;AACA,QAAIC,UAAU,GAAGlB,SAAjB,CAF4C,CAG5C;;AACAA,IAAAA,SAAS,GAAGkB,UAAU,CAACD,KAAvB;AACAb,IAAAA,KAAK,GAAGT,mBAAmB,CAACE,iBAAiB,CAACG,SAAD,CAAlB,CAA3B;AACA,WAAOI,KAAP;AACH;;AACD,MAAIjB,UAAU,CAACa,SAAD,CAAV,IAAyBZ,cAAc,CAACY,SAAD,CAA3C,EAAwD;AACpD;AACA;AACA;AACA;AACA,QAAImB,YAAY,GAAGnB,SAAnB;AACA,QAAIoB,MAAM,GAAGD,YAAY,CAACE,IAAb,KAAsBlC,UAAU,CAACgC,YAAD,CAAV,GAA2B,UAA3B,GAAwC,cAA9D,CAAb;AACA,QAAIL,OAAO,GAAGK,YAAY,CAACL,OAAb,GAAuBM,MAAM,GAAG,IAAT,GAAgBD,YAAY,CAACL,OAApD,GAA8DM,MAA5E;AACAhB,IAAAA,KAAK,GAAGY,eAAe,CAACF,OAAD,EAAUZ,kBAAV,EAA8BH,OAA9B,CAAvB;AACAb,IAAAA,qBAAqB,CAACkB,KAAD,EAAQU,OAAR,CAArB;;AACA,QAAI,UAAUK,YAAd,EAA4B;AACxBf,MAAAA,KAAK,CAACkB,IAAN,GAAavC,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKqB,KAAK,CAACkB,IAAX,CAAT,EAA2B;AAAE,6BAAqB,KAAKH,YAAY,CAACI;AAAzC,OAA3B,CAArB;AACH;;AACD,WAAOnB,KAAP;AACH;;AACD,MAAIf,OAAO,CAACW,SAAD,CAAX,EAAwB;AACpB;AACAI,IAAAA,KAAK,GAAGT,mBAAmB,CAACE,iBAAiB,CAACG,SAAD,CAAlB,CAA3B;AACA,WAAOI,KAAP;AACH;;AACD,MAAIZ,aAAa,CAACQ,SAAD,CAAb,IAA4BT,OAAO,CAACS,SAAD,CAAvC,EAAoD;AAChD;AACA;AACA;AACA,QAAIwB,eAAe,GAAGxB,SAAtB;AACAI,IAAAA,KAAK,GAAGV,oBAAoB,CAAC8B,eAAD,EAAkBtB,kBAAlB,EAAsCH,OAAO,CAAC0B,SAA9C,CAA5B;AACAxC,IAAAA,qBAAqB,CAACmB,KAAD,EAAQ;AACzBsB,MAAAA,SAAS,EAAE;AADc,KAAR,CAArB;AAGA,WAAOtB,KAAP;AACH,GAzCyE,CA0C1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAA,EAAAA,KAAK,GAAGY,eAAe,CAAChB,SAAD,EAAYE,kBAAZ,EAAgCH,OAAhC,CAAvB;AACAb,EAAAA,qBAAqB,CAACkB,KAAD,EAAQ,KAAKJ,SAAb,EAAwBG,SAAxB,CAArB;AACAlB,EAAAA,qBAAqB,CAACmB,KAAD,EAAQ;AACzBsB,IAAAA,SAAS,EAAE;AADc,GAAR,CAArB;AAGA,SAAOtB,KAAP;AACH;AACD;AACA;AACA;;AACA,OAAO,SAASY,eAAT,CAAyBW,KAAzB,EAAgCzB,kBAAhC,EAAoDH,OAApD,EAA6D;AAChE,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,IAAAA,OAAO,GAAG,EAAV;AAAe;;AACzC,MAAIK,KAAK,GAAG;AACRU,IAAAA,OAAO,EAAEa;AADD,GAAZ;;AAGA,MAAI5B,OAAO,CAACO,gBAAR,IAA4BJ,kBAAhC,EAAoD;AAChD,QAAI0B,UAAU,GAAG/B,iBAAiB,CAACK,kBAAD,CAAlC;AACA,QAAI2B,QAAQ,GAAGjC,qBAAqB,CAACgC,UAAU,CAACE,KAAZ,CAApC;AACA1B,IAAAA,KAAK,CAACwB,UAAN,GAAmB;AACfG,MAAAA,MAAM,EAAEF;AADO,KAAnB;AAGH;;AACD,SAAOzB,KAAP;AACH,C,CACD","sourcesContent":["import { __assign } from \"tslib\";\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, isDOMError, isDOMException, isError, isErrorEvent, isEvent, isPlainObject, SyncPromise, } from '@sentry/utils';\nimport { eventFromPlainObject, eventFromStacktrace, prepareFramesForEvent } from './parsers';\nimport { computeStackTrace } from './tracekit';\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nexport function eventFromException(options, exception, hint) {\n    var syntheticException = (hint && hint.syntheticException) || undefined;\n    var event = eventFromUnknownInput(exception, syntheticException, {\n        attachStacktrace: options.attachStacktrace,\n    });\n    addExceptionMechanism(event, {\n        handled: true,\n        type: 'generic',\n    });\n    event.level = Severity.Error;\n    if (hint && hint.event_id) {\n        event.event_id = hint.event_id;\n    }\n    return SyncPromise.resolve(event);\n}\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(options, message, level, hint) {\n    if (level === void 0) { level = Severity.Info; }\n    var syntheticException = (hint && hint.syntheticException) || undefined;\n    var event = eventFromString(message, syntheticException, {\n        attachStacktrace: options.attachStacktrace,\n    });\n    event.level = level;\n    if (hint && hint.event_id) {\n        event.event_id = hint.event_id;\n    }\n    return SyncPromise.resolve(event);\n}\n/**\n * @hidden\n */\nexport function eventFromUnknownInput(exception, syntheticException, options) {\n    if (options === void 0) { options = {}; }\n    var event;\n    if (isErrorEvent(exception) && exception.error) {\n        // If it is an ErrorEvent with `error` property, extract it to get actual Error\n        var errorEvent = exception;\n        // eslint-disable-next-line no-param-reassign\n        exception = errorEvent.error;\n        event = eventFromStacktrace(computeStackTrace(exception));\n        return event;\n    }\n    if (isDOMError(exception) || isDOMException(exception)) {\n        // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)\n        // then we just extract the name, code, and message, as they don't provide anything else\n        // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n        // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n        var domException = exception;\n        var name_1 = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n        var message = domException.message ? name_1 + \": \" + domException.message : name_1;\n        event = eventFromString(message, syntheticException, options);\n        addExceptionTypeValue(event, message);\n        if ('code' in domException) {\n            event.tags = __assign(__assign({}, event.tags), { 'DOMException.code': \"\" + domException.code });\n        }\n        return event;\n    }\n    if (isError(exception)) {\n        // we have a real Error object, do nothing\n        event = eventFromStacktrace(computeStackTrace(exception));\n        return event;\n    }\n    if (isPlainObject(exception) || isEvent(exception)) {\n        // If it is plain Object or Event, serialize it manually and extract options\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        var objectException = exception;\n        event = eventFromPlainObject(objectException, syntheticException, options.rejection);\n        addExceptionMechanism(event, {\n            synthetic: true,\n        });\n        return event;\n    }\n    // If none of previous checks were valid, then it means that it's not:\n    // - an instance of DOMError\n    // - an instance of DOMException\n    // - an instance of Event\n    // - an instance of Error\n    // - a valid ErrorEvent (one with an error property)\n    // - a plain Object\n    //\n    // So bail out and capture it as a simple message:\n    event = eventFromString(exception, syntheticException, options);\n    addExceptionTypeValue(event, \"\" + exception, undefined);\n    addExceptionMechanism(event, {\n        synthetic: true,\n    });\n    return event;\n}\n/**\n * @hidden\n */\nexport function eventFromString(input, syntheticException, options) {\n    if (options === void 0) { options = {}; }\n    var event = {\n        message: input,\n    };\n    if (options.attachStacktrace && syntheticException) {\n        var stacktrace = computeStackTrace(syntheticException);\n        var frames_1 = prepareFramesForEvent(stacktrace.stack);\n        event.stacktrace = {\n            frames: frames_1,\n        };\n    }\n    return event;\n}\n//# sourceMappingURL=eventbuilder.js.map"]},"metadata":{},"sourceType":"module"}
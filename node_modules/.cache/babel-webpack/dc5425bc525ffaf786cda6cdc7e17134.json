{"ast":null,"code":"import { SentryError } from './error';\nimport { SyncPromise } from './syncpromise';\n/** A simple queue that holds promises. */\n\nvar PromiseBuffer =\n/** @class */\nfunction () {\n  function PromiseBuffer(_limit) {\n    this._limit = _limit;\n    /** Internal set of queued Promises */\n\n    this._buffer = [];\n  }\n  /**\n   * Says if the buffer is ready to take more requests\n   */\n\n\n  PromiseBuffer.prototype.isReady = function () {\n    return this._limit === undefined || this.length() < this._limit;\n  };\n  /**\n   * Add a promise to the queue.\n   *\n   * @param task Can be any PromiseLike<T>\n   * @returns The original promise.\n   */\n\n\n  PromiseBuffer.prototype.add = function (task) {\n    var _this = this;\n\n    if (!this.isReady()) {\n      return SyncPromise.reject(new SentryError('Not adding Promise due to buffer limit reached.'));\n    }\n\n    if (this._buffer.indexOf(task) === -1) {\n      this._buffer.push(task);\n    }\n\n    task.then(function () {\n      return _this.remove(task);\n    }).then(null, function () {\n      return _this.remove(task).then(null, function () {// We have to add this catch here otherwise we have an unhandledPromiseRejection\n        // because it's a new Promise chain.\n      });\n    });\n    return task;\n  };\n  /**\n   * Remove a promise to the queue.\n   *\n   * @param task Can be any PromiseLike<T>\n   * @returns Removed promise.\n   */\n\n\n  PromiseBuffer.prototype.remove = function (task) {\n    var removedTask = this._buffer.splice(this._buffer.indexOf(task), 1)[0];\n\n    return removedTask;\n  };\n  /**\n   * This function returns the number of unresolved promises in the queue.\n   */\n\n\n  PromiseBuffer.prototype.length = function () {\n    return this._buffer.length;\n  };\n  /**\n   * This will drain the whole queue, returns true if queue is empty or drained.\n   * If timeout is provided and the queue takes longer to drain, the promise still resolves but with false.\n   *\n   * @param timeout Number in ms to wait until it resolves with false.\n   */\n\n\n  PromiseBuffer.prototype.drain = function (timeout) {\n    var _this = this;\n\n    return new SyncPromise(function (resolve) {\n      var capturedSetTimeout = setTimeout(function () {\n        if (timeout && timeout > 0) {\n          resolve(false);\n        }\n      }, timeout);\n      SyncPromise.all(_this._buffer).then(function () {\n        clearTimeout(capturedSetTimeout);\n        resolve(true);\n      }).then(null, function () {\n        resolve(true);\n      });\n    });\n  };\n\n  return PromiseBuffer;\n}();\n\nexport { PromiseBuffer }; //# sourceMappingURL=promisebuffer.js.map","map":{"version":3,"sources":["C:/Users/Fernando Martinez/Documents/Programacion/SignWriter/Frontend JD/node_modules/@sentry/utils/esm/promisebuffer.js"],"names":["SentryError","SyncPromise","PromiseBuffer","_limit","_buffer","prototype","isReady","undefined","length","add","task","_this","reject","indexOf","push","then","remove","removedTask","splice","drain","timeout","resolve","capturedSetTimeout","setTimeout","all","clearTimeout"],"mappings":"AAAA,SAASA,WAAT,QAA4B,SAA5B;AACA,SAASC,WAAT,QAA4B,eAA5B;AACA;;AACA,IAAIC,aAAa;AAAG;AAAe,YAAY;AAC3C,WAASA,aAAT,CAAuBC,MAAvB,EAA+B;AAC3B,SAAKA,MAAL,GAAcA,MAAd;AACA;;AACA,SAAKC,OAAL,GAAe,EAAf;AACH;AACD;AACJ;AACA;;;AACIF,EAAAA,aAAa,CAACG,SAAd,CAAwBC,OAAxB,GAAkC,YAAY;AAC1C,WAAO,KAAKH,MAAL,KAAgBI,SAAhB,IAA6B,KAAKC,MAAL,KAAgB,KAAKL,MAAzD;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;;;AACID,EAAAA,aAAa,CAACG,SAAd,CAAwBI,GAAxB,GAA8B,UAAUC,IAAV,EAAgB;AAC1C,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAI,CAAC,KAAKL,OAAL,EAAL,EAAqB;AACjB,aAAOL,WAAW,CAACW,MAAZ,CAAmB,IAAIZ,WAAJ,CAAgB,iDAAhB,CAAnB,CAAP;AACH;;AACD,QAAI,KAAKI,OAAL,CAAaS,OAAb,CAAqBH,IAArB,MAA+B,CAAC,CAApC,EAAuC;AACnC,WAAKN,OAAL,CAAaU,IAAb,CAAkBJ,IAAlB;AACH;;AACDA,IAAAA,IAAI,CACCK,IADL,CACU,YAAY;AAAE,aAAOJ,KAAK,CAACK,MAAN,CAAaN,IAAb,CAAP;AAA4B,KADpD,EAEKK,IAFL,CAEU,IAFV,EAEgB,YAAY;AACxB,aAAOJ,KAAK,CAACK,MAAN,CAAaN,IAAb,EAAmBK,IAAnB,CAAwB,IAAxB,EAA8B,YAAY,CAC7C;AACA;AACH,OAHM,CAAP;AAIH,KAPD;AAQA,WAAOL,IAAP;AACH,GAjBD;AAkBA;AACJ;AACA;AACA;AACA;AACA;;;AACIR,EAAAA,aAAa,CAACG,SAAd,CAAwBW,MAAxB,GAAiC,UAAUN,IAAV,EAAgB;AAC7C,QAAIO,WAAW,GAAG,KAAKb,OAAL,CAAac,MAAb,CAAoB,KAAKd,OAAL,CAAaS,OAAb,CAAqBH,IAArB,CAApB,EAAgD,CAAhD,EAAmD,CAAnD,CAAlB;;AACA,WAAOO,WAAP;AACH,GAHD;AAIA;AACJ;AACA;;;AACIf,EAAAA,aAAa,CAACG,SAAd,CAAwBG,MAAxB,GAAiC,YAAY;AACzC,WAAO,KAAKJ,OAAL,CAAaI,MAApB;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;;;AACIN,EAAAA,aAAa,CAACG,SAAd,CAAwBc,KAAxB,GAAgC,UAAUC,OAAV,EAAmB;AAC/C,QAAIT,KAAK,GAAG,IAAZ;;AACA,WAAO,IAAIV,WAAJ,CAAgB,UAAUoB,OAAV,EAAmB;AACtC,UAAIC,kBAAkB,GAAGC,UAAU,CAAC,YAAY;AAC5C,YAAIH,OAAO,IAAIA,OAAO,GAAG,CAAzB,EAA4B;AACxBC,UAAAA,OAAO,CAAC,KAAD,CAAP;AACH;AACJ,OAJkC,EAIhCD,OAJgC,CAAnC;AAKAnB,MAAAA,WAAW,CAACuB,GAAZ,CAAgBb,KAAK,CAACP,OAAtB,EACKW,IADL,CACU,YAAY;AAClBU,QAAAA,YAAY,CAACH,kBAAD,CAAZ;AACAD,QAAAA,OAAO,CAAC,IAAD,CAAP;AACH,OAJD,EAKKN,IALL,CAKU,IALV,EAKgB,YAAY;AACxBM,QAAAA,OAAO,CAAC,IAAD,CAAP;AACH,OAPD;AAQH,KAdM,CAAP;AAeH,GAjBD;;AAkBA,SAAOnB,aAAP;AACH,CA7EkC,EAAnC;;AA8EA,SAASA,aAAT,G,CACA","sourcesContent":["import { SentryError } from './error';\nimport { SyncPromise } from './syncpromise';\n/** A simple queue that holds promises. */\nvar PromiseBuffer = /** @class */ (function () {\n    function PromiseBuffer(_limit) {\n        this._limit = _limit;\n        /** Internal set of queued Promises */\n        this._buffer = [];\n    }\n    /**\n     * Says if the buffer is ready to take more requests\n     */\n    PromiseBuffer.prototype.isReady = function () {\n        return this._limit === undefined || this.length() < this._limit;\n    };\n    /**\n     * Add a promise to the queue.\n     *\n     * @param task Can be any PromiseLike<T>\n     * @returns The original promise.\n     */\n    PromiseBuffer.prototype.add = function (task) {\n        var _this = this;\n        if (!this.isReady()) {\n            return SyncPromise.reject(new SentryError('Not adding Promise due to buffer limit reached.'));\n        }\n        if (this._buffer.indexOf(task) === -1) {\n            this._buffer.push(task);\n        }\n        task\n            .then(function () { return _this.remove(task); })\n            .then(null, function () {\n            return _this.remove(task).then(null, function () {\n                // We have to add this catch here otherwise we have an unhandledPromiseRejection\n                // because it's a new Promise chain.\n            });\n        });\n        return task;\n    };\n    /**\n     * Remove a promise to the queue.\n     *\n     * @param task Can be any PromiseLike<T>\n     * @returns Removed promise.\n     */\n    PromiseBuffer.prototype.remove = function (task) {\n        var removedTask = this._buffer.splice(this._buffer.indexOf(task), 1)[0];\n        return removedTask;\n    };\n    /**\n     * This function returns the number of unresolved promises in the queue.\n     */\n    PromiseBuffer.prototype.length = function () {\n        return this._buffer.length;\n    };\n    /**\n     * This will drain the whole queue, returns true if queue is empty or drained.\n     * If timeout is provided and the queue takes longer to drain, the promise still resolves but with false.\n     *\n     * @param timeout Number in ms to wait until it resolves with false.\n     */\n    PromiseBuffer.prototype.drain = function (timeout) {\n        var _this = this;\n        return new SyncPromise(function (resolve) {\n            var capturedSetTimeout = setTimeout(function () {\n                if (timeout && timeout > 0) {\n                    resolve(false);\n                }\n            }, timeout);\n            SyncPromise.all(_this._buffer)\n                .then(function () {\n                clearTimeout(capturedSetTimeout);\n                resolve(true);\n            })\n                .then(null, function () {\n                resolve(true);\n            });\n        });\n    };\n    return PromiseBuffer;\n}());\nexport { PromiseBuffer };\n//# sourceMappingURL=promisebuffer.js.map"]},"metadata":{},"sourceType":"module"}
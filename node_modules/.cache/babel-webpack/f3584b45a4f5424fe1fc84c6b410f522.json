{"ast":null,"code":"import _slicedToArray from \"C:/Users/Fernando Martinez/Documents/Programacion/SignWriter/Frontend JD/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:/Users/Fernando Martinez/Documents/Programacion/SignWriter/Frontend JD/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/Fernando Martinez/Documents/Programacion/SignWriter/Frontend JD/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Injector, Optional, Inject, NgModule } from '@angular/core';\nimport { Auth0Client } from '@auth0/auth0-spa-js';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@auth0/auth0-spa-js';\nexport { InMemoryCache, LocalStorageCache, User } from '@auth0/auth0-spa-js';\nimport { BehaviorSubject, Subject, ReplaySubject, merge, defer, of, iif, from, throwError } from 'rxjs';\nimport { scan, filter, distinctUntilChanged, switchMap, mergeMap, shareReplay, concatMap, catchError, tap, takeUntil, withLatestFrom, map, take, pluck, first } from 'rxjs/operators';\nimport { __rest } from 'tslib';\nimport { Router } from '@angular/router';\nimport * as i1 from '@angular/common';\nimport { Location } from '@angular/common';\nvar useragent = {\n  name: '@auth0/auth0-angular',\n  version: '1.9.0'\n};\n\nvar Auth0ClientFactory = /*#__PURE__*/function () {\n  function Auth0ClientFactory() {\n    _classCallCheck(this, Auth0ClientFactory);\n  }\n\n  _createClass(Auth0ClientFactory, null, [{\n    key: \"createClient\",\n    value: function createClient(configFactory) {\n      var config = configFactory.get();\n\n      if (!config) {\n        throw new Error('Configuration must be specified either through AuthModule.forRoot or through AuthClientConfig.set');\n      }\n\n      var redirectUri = config.redirectUri,\n          clientId = config.clientId,\n          maxAge = config.maxAge,\n          httpInterceptor = config.httpInterceptor,\n          rest = __rest(config, [\"redirectUri\", \"clientId\", \"maxAge\", \"httpInterceptor\"]);\n\n      return new Auth0Client(Object.assign(Object.assign({\n        redirect_uri: redirectUri || window.location.origin,\n        client_id: clientId,\n        max_age: maxAge\n      }, rest), {\n        auth0Client: {\n          name: useragent.name,\n          version: useragent.version\n        }\n      }));\n    }\n  }]);\n\n  return Auth0ClientFactory;\n}();\n\nvar Auth0ClientService = new InjectionToken('auth0.client');\n\nvar AbstractNavigator = /*#__PURE__*/function () {\n  function AbstractNavigator(location, injector) {\n    _classCallCheck(this, AbstractNavigator);\n\n    this.location = location;\n\n    try {\n      this.router = injector.get(Router);\n    } catch (_a) {}\n  }\n  /**\n   * Navigates to the specified url. The router will be used if one is available, otherwise it falls back\n   * to `window.history.replaceState`.\n   * @param url The url to navigate to\n   */\n\n\n  _createClass(AbstractNavigator, [{\n    key: \"navigateByUrl\",\n    value: function navigateByUrl(url) {\n      if (this.router) {\n        this.router.navigateByUrl(url);\n        return;\n      }\n\n      this.location.replaceState(url);\n    }\n  }]);\n\n  return AbstractNavigator;\n}();\n\nAbstractNavigator.ɵfac = function AbstractNavigator_Factory(t) {\n  return new (t || AbstractNavigator)(ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n};\n\nAbstractNavigator.ɵprov = i0.ɵɵdefineInjectable({\n  factory: function AbstractNavigator_Factory() {\n    return new AbstractNavigator(i0.ɵɵinject(i1.Location), i0.ɵɵinject(i0.INJECTOR));\n  },\n  token: AbstractNavigator,\n  providedIn: \"root\"\n});\n\nAbstractNavigator.ctorParameters = function () {\n  return [{\n    type: Location\n  }, {\n    type: Injector\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbstractNavigator, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc1.Location\n    }, {\n      type: ɵngcc0.Injector\n    }];\n  }, null);\n})();\n/**\n * A custom type guard to help identify route definitions that are actually HttpInterceptorRouteConfig types.\n * @param def The route definition type\n */\n\n\nfunction isHttpInterceptorRouteConfig(def) {\n  return typeof def !== 'string';\n}\n/**\n * Gets and sets configuration for the internal Auth0 client. This can be\n * used to provide configuration outside of using AuthModule.forRoot, i.e. from\n * a factory provided by APP_INITIALIZER.\n *\n * @usage\n *\n * ```js\n * // app.module.ts\n * // ---------------------------\n * import { AuthModule, AuthClientConfig } from '@auth0/auth0-angular';\n *\n * // Provide an initializer function that returns a Promise\n * function configInitializer(\n *   http: HttpClient,\n *   config: AuthClientConfig\n * ) {\n *   return () =>\n *     http\n *       .get('/config')\n *       .toPromise()\n *       .then((loadedConfig: any) => config.set(loadedConfig));   // Set the config that was loaded asynchronously here\n * }\n *\n * // Provide APP_INITIALIZER with this function. Note that there is no config passed to AuthModule.forRoot\n * imports: [\n *   // other imports..\n *\n *   HttpClientModule,\n *   AuthModule.forRoot(),   //<- don't pass any config here\n * ],\n * providers: [\n *   {\n *     provide: APP_INITIALIZER,\n *     useFactory: configInitializer,    // <- pass your initializer function here\n *     deps: [HttpClient, AuthClientConfig],\n *     multi: true,\n *   },\n * ],\n * ```\n *\n */\n\n\nvar AuthClientConfig = /*#__PURE__*/function () {\n  function AuthClientConfig(config) {\n    _classCallCheck(this, AuthClientConfig);\n\n    if (config) {\n      this.set(config);\n    }\n  }\n  /**\n   * Sets configuration to be read by other consumers of the service (see usage notes)\n   * @param config The configuration to set\n   */\n\n\n  _createClass(AuthClientConfig, [{\n    key: \"set\",\n    value: function set(config) {\n      this.config = config;\n    }\n    /**\n     * Gets the config that has been set by other consumers of the service\n     */\n\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this.config;\n    }\n  }]);\n\n  return AuthClientConfig;\n}();\n\nAuthClientConfig.ɵfac = function AuthClientConfig_Factory(t) {\n  return new (t || AuthClientConfig)(ɵngcc0.ɵɵinject(AuthConfigService, 8));\n};\n\nAuthClientConfig.ɵprov = i0.ɵɵdefineInjectable({\n  factory: function AuthClientConfig_Factory() {\n    return new AuthClientConfig(i0.ɵɵinject(AuthConfigService, 8));\n  },\n  token: AuthClientConfig,\n  providedIn: \"root\"\n});\n\nAuthClientConfig.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [AuthConfigService]\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthClientConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [AuthConfigService]\n      }]\n    }];\n  }, null);\n})();\n/**\n * Injection token for accessing configuration.\n *\n * @usageNotes\n *\n * Use the `Inject` decorator to access the configuration from a service or component:\n *\n * ```\n * class MyService(@Inject(AuthConfigService) config: AuthConfig) {}\n * ```\n */\n\n\nvar AuthConfigService = new InjectionToken('auth0-angular.config');\n/**\n * Tracks the Authentication State for the SDK\n */\n\nvar AuthState = /*#__PURE__*/function () {\n  function AuthState(auth0Client) {\n    var _this = this;\n\n    _classCallCheck(this, AuthState);\n\n    this.auth0Client = auth0Client;\n    this.isLoadingSubject$ = new BehaviorSubject(true);\n    this.refresh$ = new Subject();\n    this.accessToken$ = new ReplaySubject(1);\n    this.errorSubject$ = new ReplaySubject(1);\n    /**\n     * Emits boolean values indicating the loading state of the SDK.\n     */\n\n    this.isLoading$ = this.isLoadingSubject$.asObservable();\n    /**\n     * Trigger used to pull User information from the Auth0Client.\n     * Triggers when the access token has changed.\n     */\n\n    this.accessTokenTrigger$ = this.accessToken$.pipe(scan(function (acc, current) {\n      return {\n        previous: acc.current,\n        current: current\n      };\n    }, {\n      current: null,\n      previous: null\n    }), filter(function (_ref) {\n      var previous = _ref.previous,\n          current = _ref.current;\n      return previous !== current;\n    }));\n    /**\n     * Trigger used to pull User information from the Auth0Client.\n     * Triggers when an event occurs that needs to retrigger the User Profile information.\n     * Events: Login, Access Token change and Logout\n     */\n\n    this.isAuthenticatedTrigger$ = this.isLoading$.pipe(filter(function (loading) {\n      return !loading;\n    }), distinctUntilChanged(), switchMap(function () {\n      return (// To track the value of isAuthenticated over time, we need to merge:\n        //  - the current value\n        //  - the value whenever the access token changes. (this should always be true of there is an access token\n        //    but it is safer to pass this through this.auth0Client.isAuthenticated() nevertheless)\n        //  - the value whenever refreshState$ emits\n        merge(defer(function () {\n          return _this.auth0Client.isAuthenticated();\n        }), _this.accessTokenTrigger$.pipe(mergeMap(function () {\n          return _this.auth0Client.isAuthenticated();\n        })), _this.refresh$.pipe(mergeMap(function () {\n          return _this.auth0Client.isAuthenticated();\n        })))\n      );\n    }));\n    /**\n     * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n     * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n     */\n\n    this.isAuthenticated$ = this.isAuthenticatedTrigger$.pipe(distinctUntilChanged(), shareReplay(1));\n    /**\n     * Emits details about the authenticated user, or null if not authenticated.\n     */\n\n    this.user$ = this.isAuthenticatedTrigger$.pipe(concatMap(function (authenticated) {\n      return authenticated ? _this.auth0Client.getUser() : of(null);\n    }));\n    /**\n     * Emits ID token claims when authenticated, or null if not authenticated.\n     */\n\n    this.idTokenClaims$ = this.isAuthenticatedTrigger$.pipe(concatMap(function (authenticated) {\n      return authenticated ? _this.auth0Client.getIdTokenClaims() : of(null);\n    }));\n    /**\n     * Emits errors that occur during login, or when checking for an active session on startup.\n     */\n\n    this.error$ = this.errorSubject$.asObservable();\n  }\n  /**\n   * Update the isLoading state using the provided value\n   * @param isLoading The new value for isLoading\n   */\n\n\n  _createClass(AuthState, [{\n    key: \"setIsLoading\",\n    value: function setIsLoading(isLoading) {\n      this.isLoadingSubject$.next(isLoading);\n    }\n    /**\n     * Refresh the state to ensure the `isAuthenticated`, `user$` and `idTokenClaims$`\n     * reflect the most up-to-date values from  Auth0Client.\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.refresh$.next();\n    }\n    /**\n     * Update the access token, doing so will also refresh the state.\n     * @param accessToken The new Access Token\n     */\n\n  }, {\n    key: \"setAccessToken\",\n    value: function setAccessToken(accessToken) {\n      this.accessToken$.next(accessToken);\n    }\n    /**\n     * Emits the error in the `error$` observable.\n     * @param error The new error\n     */\n\n  }, {\n    key: \"setError\",\n    value: function setError(error) {\n      this.errorSubject$.next(error);\n    }\n  }]);\n\n  return AuthState;\n}();\n\nAuthState.ɵfac = function AuthState_Factory(t) {\n  return new (t || AuthState)(ɵngcc0.ɵɵinject(Auth0ClientService));\n};\n\nAuthState.ɵprov = i0.ɵɵdefineInjectable({\n  factory: function AuthState_Factory() {\n    return new AuthState(i0.ɵɵinject(Auth0ClientService));\n  },\n  token: AuthState,\n  providedIn: \"root\"\n});\n\nAuthState.ctorParameters = function () {\n  return [{\n    type: Auth0Client,\n    decorators: [{\n      type: Inject,\n      args: [Auth0ClientService]\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthState, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc2.Auth0Client,\n      decorators: [{\n        type: Inject,\n        args: [Auth0ClientService]\n      }]\n    }];\n  }, null);\n})();\n\nvar AuthService = /*#__PURE__*/function () {\n  function AuthService(auth0Client, configFactory, navigator, authState) {\n    var _this2 = this;\n\n    _classCallCheck(this, AuthService);\n\n    this.auth0Client = auth0Client;\n    this.configFactory = configFactory;\n    this.navigator = navigator;\n    this.authState = authState;\n    this.appStateSubject$ = new ReplaySubject(1); // https://stackoverflow.com/a/41177163\n\n    this.ngUnsubscribe$ = new Subject();\n    /**\n     * Emits boolean values indicating the loading state of the SDK.\n     */\n\n    this.isLoading$ = this.authState.isLoading$;\n    /**\n     * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n     * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n     */\n\n    this.isAuthenticated$ = this.authState.isAuthenticated$;\n    /**\n     * Emits details about the authenticated user, or null if not authenticated.\n     */\n\n    this.user$ = this.authState.user$;\n    /**\n     * Emits ID token claims when authenticated, or null if not authenticated.\n     */\n\n    this.idTokenClaims$ = this.authState.idTokenClaims$;\n    /**\n     * Emits errors that occur during login, or when checking for an active session on startup.\n     */\n\n    this.error$ = this.authState.error$;\n    /**\n     * Emits the value (if any) that was passed to the `loginWithRedirect` method call\n     * but only **after** `handleRedirectCallback` is first called\n     */\n\n    this.appState$ = this.appStateSubject$.asObservable();\n\n    var checkSessionOrCallback$ = function checkSessionOrCallback$(isCallback) {\n      return iif(function () {\n        return isCallback;\n      }, _this2.handleRedirectCallback(), defer(function () {\n        return _this2.auth0Client.checkSession();\n      }));\n    };\n\n    this.shouldHandleCallback().pipe(switchMap(function (isCallback) {\n      return checkSessionOrCallback$(isCallback).pipe(catchError(function (error) {\n        var config = _this2.configFactory.get();\n\n        _this2.authState.setError(error);\n\n        _this2.navigator.navigateByUrl(config.errorPath || '/');\n\n        return of(undefined);\n      }));\n    }), tap(function () {\n      _this2.authState.setIsLoading(false);\n    }), takeUntil(this.ngUnsubscribe$)).subscribe();\n  }\n  /**\n   * Called when the service is destroyed\n   */\n\n\n  _createClass(AuthService, [{\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      // https://stackoverflow.com/a/41177163\n      this.ngUnsubscribe$.next();\n      this.ngUnsubscribe$.complete();\n    }\n    /**\n     * ```js\n     * loginWithRedirect(options);\n     * ```\n     *\n     * Performs a redirect to `/authorize` using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated.\n     *\n     * @param options The login options\n     */\n\n  }, {\n    key: \"loginWithRedirect\",\n    value: function loginWithRedirect(options) {\n      return from(this.auth0Client.loginWithRedirect(options));\n    }\n    /**\n     * ```js\n     * await loginWithPopup(options);\n     * ```\n     *\n     * Opens a popup with the `/authorize` URL using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated. If the response is successful,\n     * results will be valid according to their expiration times.\n     *\n     * IMPORTANT: This method has to be called from an event handler\n     * that was started by the user like a button click, for example,\n     * otherwise the popup will be blocked in most browsers.\n     *\n     * @param options The login options\n     * @param config Configuration for the popup window\n     */\n\n  }, {\n    key: \"loginWithPopup\",\n    value: function loginWithPopup(options, config) {\n      var _this3 = this;\n\n      return from(this.auth0Client.loginWithPopup(options, config).then(function () {\n        _this3.authState.refresh();\n      }));\n    }\n    /**\n     * ```js\n     * logout();\n     * ```\n     *\n     * Clears the application session and performs a redirect to `/v2/logout`, using\n     * the parameters provided as arguments, to clear the Auth0 session.\n     * If the `federated` option is specified it also clears the Identity Provider session.\n     * If the `localOnly` option is specified, it only clears the application session.\n     * It is invalid to set both the `federated` and `localOnly` options to `true`,\n     * and an error will be thrown if you do.\n     * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).\n     *\n     * @param options The logout options\n     */\n\n  }, {\n    key: \"logout\",\n    value: function logout(options) {\n      var _this4 = this;\n\n      var logout = this.auth0Client.logout(options) || of(null);\n      from(logout).subscribe(function () {\n        if (options === null || options === void 0 ? void 0 : options.localOnly) {\n          _this4.authState.refresh();\n        }\n      });\n    }\n    /**\n     * ```js\n     * getAccessTokenSilently(options).subscribe(token => ...)\n     * ```\n     *\n     * If there's a valid token stored, return it. Otherwise, opens an\n     * iframe with the `/authorize` URL using the parameters provided\n     * as arguments. Random and secure `state` and `nonce` parameters\n     * will be auto-generated. If the response is successful, results\n     * will be valid according to their expiration times.\n     *\n     * If refresh tokens are used, the token endpoint is called directly with the\n     * 'refresh_token' grant. If no refresh token is available to make this call,\n     * the SDK falls back to using an iframe to the '/authorize' URL.\n     *\n     * This method may use a web worker to perform the token call if the in-memory\n     * cache is used.\n     *\n     * If an `audience` value is given to this function, the SDK always falls\n     * back to using an iframe to make the token exchange.\n     *\n     * Note that in all cases, falling back to an iframe requires access to\n     * the `auth0` cookie, and thus will not work in browsers that block third-party\n     * cookies by default (Safari, Brave, etc).\n     *\n     * @param options The options for configuring the token fetch.\n     */\n\n  }, {\n    key: \"getAccessTokenSilently\",\n    value: function getAccessTokenSilently() {\n      var _this5 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return of(this.auth0Client).pipe(concatMap(function (client) {\n        return options.detailedResponse === true ? client.getTokenSilently(Object.assign(Object.assign({}, options), {\n          detailedResponse: true\n        })) : client.getTokenSilently(options);\n      }), tap(function (token) {\n        return _this5.authState.setAccessToken(typeof token === 'string' ? token : token.access_token);\n      }), catchError(function (error) {\n        _this5.authState.setError(error);\n\n        _this5.authState.refresh();\n\n        return throwError(error);\n      }));\n    }\n    /**\n     * ```js\n     * getTokenWithPopup(options).subscribe(token => ...)\n     * ```\n     *\n     * Get an access token interactively.\n     *\n     * Opens a popup with the `/authorize` URL using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated. If the response is successful,\n     * results will be valid according to their expiration times.\n     */\n\n  }, {\n    key: \"getAccessTokenWithPopup\",\n    value: function getAccessTokenWithPopup(options) {\n      var _this6 = this;\n\n      return of(this.auth0Client).pipe(concatMap(function (client) {\n        return client.getTokenWithPopup(options);\n      }), tap(function (token) {\n        return _this6.authState.setAccessToken(token);\n      }), catchError(function (error) {\n        _this6.authState.setError(error);\n\n        _this6.authState.refresh();\n\n        return throwError(error);\n      }));\n    }\n    /**\n     * ```js\n     * getUser(options).subscribe(user => ...);\n     * ```\n     *\n     * Returns the user information if available (decoded\n     * from the `id_token`).\n     *\n     * If you provide an audience or scope, they should match an existing Access Token\n     * (the SDK stores a corresponding ID Token with every Access Token, and uses the\n     * scope and audience to look up the ID Token)\n     *\n     * @remarks\n     *\n     * The returned observable will emit once and then complete.\n     *\n     * @typeparam TUser The type to return, has to extend {@link User}.\n     * @param options The options to get the user\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function getUser(options) {\n      var _this7 = this;\n\n      return defer(function () {\n        return _this7.auth0Client.getUser(options);\n      });\n    }\n    /**\n     * ```js\n     * getIdTokenClaims(options).subscribe(claims => ...);\n     * ```\n     *\n     * Returns all claims from the id_token if available.\n     *\n     * If you provide an audience or scope, they should match an existing Access Token\n     * (the SDK stores a corresponding ID Token with every Access Token, and uses the\n     * scope and audience to look up the ID Token)\n     *\n     * @remarks\n     *\n     * The returned observable will emit once and then complete.\n     *\n     * @param options The options to get the Id token claims\n     */\n\n  }, {\n    key: \"getIdTokenClaims\",\n    value: function getIdTokenClaims(options) {\n      var _this8 = this;\n\n      return defer(function () {\n        return _this8.auth0Client.getIdTokenClaims(options);\n      });\n    }\n    /**\n     * ```js\n     * handleRedirectCallback(url).subscribe(result => ...)\n     * ```\n     *\n     * After the browser redirects back to the callback page,\n     * call `handleRedirectCallback` to handle success and error\n     * responses from Auth0. If the response is successful, results\n     * will be valid according to their expiration times.\n     *\n     * Calling this method also refreshes the authentication and user states.\n     *\n     * @param url The URL to that should be used to retrieve the `state` and `code` values. Defaults to `window.location.href` if not given.\n     */\n\n  }, {\n    key: \"handleRedirectCallback\",\n    value: function handleRedirectCallback(url) {\n      var _this9 = this;\n\n      return defer(function () {\n        return _this9.auth0Client.handleRedirectCallback(url);\n      }).pipe(withLatestFrom(this.authState.isLoading$), tap(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            result = _ref3[0],\n            isLoading = _ref3[1];\n\n        var _a;\n\n        if (!isLoading) {\n          _this9.authState.refresh();\n        }\n\n        var appState = result === null || result === void 0 ? void 0 : result.appState;\n        var target = (_a = appState === null || appState === void 0 ? void 0 : appState.target) !== null && _a !== void 0 ? _a : '/';\n\n        if (appState) {\n          _this9.appStateSubject$.next(appState);\n        }\n\n        _this9.navigator.navigateByUrl(target);\n      }), map(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 1),\n            result = _ref5[0];\n\n        return result;\n      }));\n    }\n    /**\n     * ```js\n     * buildAuthorizeUrl().subscribe(url => ...)\n     * ```\n     *\n     * Builds an `/authorize` URL for loginWithRedirect using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated.\n     * @param options The options\n     * @returns A URL to the authorize endpoint\n     */\n\n  }, {\n    key: \"buildAuthorizeUrl\",\n    value: function buildAuthorizeUrl(options) {\n      var _this10 = this;\n\n      return defer(function () {\n        return _this10.auth0Client.buildAuthorizeUrl(options);\n      });\n    }\n    /**\n     * ```js\n     * buildLogoutUrl().subscribe(url => ...)\n     * ```\n     * Builds a URL to the logout endpoint.\n     *\n     * @param options The options used to configure the parameters that appear in the logout endpoint URL.\n     * @returns a URL to the logout endpoint using the parameters provided as arguments.\n     */\n\n  }, {\n    key: \"buildLogoutUrl\",\n    value: function buildLogoutUrl(options) {\n      return of(this.auth0Client.buildLogoutUrl(options));\n    }\n  }, {\n    key: \"shouldHandleCallback\",\n    value: function shouldHandleCallback() {\n      var _this11 = this;\n\n      return of(location.search).pipe(map(function (search) {\n        return (search.includes('code=') || search.includes('error=')) && search.includes('state=') && !_this11.configFactory.get().skipRedirectCallback;\n      }));\n    }\n  }]);\n\n  return AuthService;\n}();\n\nAuthService.ɵfac = function AuthService_Factory(t) {\n  return new (t || AuthService)(ɵngcc0.ɵɵinject(Auth0ClientService), ɵngcc0.ɵɵinject(AuthClientConfig), ɵngcc0.ɵɵinject(AbstractNavigator), ɵngcc0.ɵɵinject(AuthState));\n};\n\nAuthService.ɵprov = i0.ɵɵdefineInjectable({\n  factory: function AuthService_Factory() {\n    return new AuthService(i0.ɵɵinject(Auth0ClientService), i0.ɵɵinject(AuthClientConfig), i0.ɵɵinject(AbstractNavigator), i0.ɵɵinject(AuthState));\n  },\n  token: AuthService,\n  providedIn: \"root\"\n});\n\nAuthService.ctorParameters = function () {\n  return [{\n    type: Auth0Client,\n    decorators: [{\n      type: Inject,\n      args: [Auth0ClientService]\n    }]\n  }, {\n    type: AuthClientConfig\n  }, {\n    type: AbstractNavigator\n  }, {\n    type: AuthState\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc2.Auth0Client,\n      decorators: [{\n        type: Inject,\n        args: [Auth0ClientService]\n      }]\n    }, {\n      type: AuthClientConfig\n    }, {\n      type: AbstractNavigator\n    }, {\n      type: AuthState\n    }];\n  }, null);\n})();\n\nvar AuthGuard = /*#__PURE__*/function () {\n  function AuthGuard(auth) {\n    _classCallCheck(this, AuthGuard);\n\n    this.auth = auth;\n  }\n\n  _createClass(AuthGuard, [{\n    key: \"canLoad\",\n    value: function canLoad(route, segments) {\n      return this.auth.isAuthenticated$.pipe(take(1));\n    }\n  }, {\n    key: \"canActivate\",\n    value: function canActivate(next, state) {\n      return this.redirectIfUnauthenticated(state);\n    }\n  }, {\n    key: \"canActivateChild\",\n    value: function canActivateChild(childRoute, state) {\n      return this.redirectIfUnauthenticated(state);\n    }\n  }, {\n    key: \"redirectIfUnauthenticated\",\n    value: function redirectIfUnauthenticated(state) {\n      var _this12 = this;\n\n      return this.auth.isAuthenticated$.pipe(tap(function (loggedIn) {\n        if (!loggedIn) {\n          _this12.auth.loginWithRedirect({\n            appState: {\n              target: state.url\n            }\n          });\n        }\n      }));\n    }\n  }]);\n\n  return AuthGuard;\n}();\n\nAuthGuard.ɵfac = function AuthGuard_Factory(t) {\n  return new (t || AuthGuard)(ɵngcc0.ɵɵinject(AuthService));\n};\n\nAuthGuard.ɵprov = i0.ɵɵdefineInjectable({\n  factory: function AuthGuard_Factory() {\n    return new AuthGuard(i0.ɵɵinject(AuthService));\n  },\n  token: AuthGuard,\n  providedIn: \"root\"\n});\n\nAuthGuard.ctorParameters = function () {\n  return [{\n    type: AuthService\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AuthService\n    }];\n  }, null);\n})();\n\nvar AuthModule = /*#__PURE__*/function () {\n  function AuthModule() {\n    _classCallCheck(this, AuthModule);\n  }\n\n  _createClass(AuthModule, null, [{\n    key: \"forRoot\",\n    value:\n    /**\n     * Initialize the authentication module system. Configuration can either be specified here,\n     * or by calling AuthClientConfig.set (perhaps from an APP_INITIALIZER factory function).\n     * @param config The optional configuration for the SDK.\n     */\n    function forRoot(config) {\n      return {\n        ngModule: AuthModule,\n        providers: [AuthService, AuthGuard, {\n          provide: AuthConfigService,\n          useValue: config\n        }, {\n          provide: Auth0ClientService,\n          useFactory: Auth0ClientFactory.createClient,\n          deps: [AuthClientConfig]\n        }]\n      };\n    }\n  }]);\n\n  return AuthModule;\n}();\n\nAuthModule.ɵfac = function AuthModule_Factory(t) {\n  return new (t || AuthModule)();\n};\n\nAuthModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: AuthModule\n});\nAuthModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\nvar AuthHttpInterceptor = /*#__PURE__*/function () {\n  function AuthHttpInterceptor(configFactory, auth0Client, authState) {\n    _classCallCheck(this, AuthHttpInterceptor);\n\n    this.configFactory = configFactory;\n    this.auth0Client = auth0Client;\n    this.authState = authState;\n  }\n\n  _createClass(AuthHttpInterceptor, [{\n    key: \"intercept\",\n    value: function intercept(req, next) {\n      var _this13 = this;\n\n      var _a;\n\n      var config = this.configFactory.get();\n\n      if (!((_a = config.httpInterceptor) === null || _a === void 0 ? void 0 : _a.allowedList)) {\n        return next.handle(req);\n      }\n\n      return this.findMatchingRoute(req, config.httpInterceptor).pipe(concatMap(function (route) {\n        return iif( // Check if a route was matched\n        function () {\n          return route !== null;\n        }, // If we have a matching route, call getTokenSilently and attach the token to the\n        // outgoing request\n        of(route).pipe(pluck('tokenOptions'), concatMap(function (options) {\n          return _this13.getAccessTokenSilently(options).pipe(catchError(function (err) {\n            if (_this13.allowAnonymous(route, err)) {\n              return of('');\n            }\n\n            _this13.authState.setError(err);\n\n            return throwError(err);\n          }));\n        }), switchMap(function (token) {\n          // Clone the request and attach the bearer token\n          var clone = token ? req.clone({\n            headers: req.headers.set('Authorization', \"Bearer \".concat(token))\n          }) : req;\n          return next.handle(clone);\n        })), // If the URI being called was not found in our httpInterceptor config, simply\n        // pass the request through without attaching a token\n        next.handle(req));\n      }));\n    }\n    /**\n     * Duplicate of AuthService.getAccessTokenSilently, but with a slightly different error handling.\n     * Only used internally in the interceptor.\n     * @param options The options for configuring the token fetch.\n     */\n\n  }, {\n    key: \"getAccessTokenSilently\",\n    value: function getAccessTokenSilently(options) {\n      var _this14 = this;\n\n      return of(this.auth0Client).pipe(concatMap(function (client) {\n        return client.getTokenSilently(options);\n      }), tap(function (token) {\n        return _this14.authState.setAccessToken(token);\n      }), catchError(function (error) {\n        _this14.authState.refresh();\n\n        return throwError(error);\n      }));\n    }\n    /**\n     * Strips the query and fragment from the given uri\n     * @param uri The uri to remove the query and fragment from\n     */\n\n  }, {\n    key: \"stripQueryFrom\",\n    value: function stripQueryFrom(uri) {\n      if (uri.indexOf('?') > -1) {\n        uri = uri.substr(0, uri.indexOf('?'));\n      }\n\n      if (uri.indexOf('#') > -1) {\n        uri = uri.substr(0, uri.indexOf('#'));\n      }\n\n      return uri;\n    }\n    /**\n     * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against\n     * the interceptor route configuration.\n     * @param route The route to test\n     * @param request The HTTP request\n     */\n\n  }, {\n    key: \"canAttachToken\",\n    value: function canAttachToken(route, request) {\n      var _this15 = this;\n\n      var testPrimitive = function testPrimitive(value) {\n        if (!value) {\n          return false;\n        }\n\n        var requestPath = _this15.stripQueryFrom(request.url);\n\n        if (value === requestPath) {\n          return true;\n        } // If the URL ends with an asterisk, match using startsWith.\n\n\n        return value.indexOf('*') === value.length - 1 && request.url.startsWith(value.substr(0, value.length - 1));\n      };\n\n      if (isHttpInterceptorRouteConfig(route)) {\n        if (route.httpMethod && route.httpMethod !== request.method) {\n          return false;\n        }\n        /* istanbul ignore if */\n\n\n        if (!route.uri && !route.uriMatcher) {\n          console.warn('Either a uri or uriMatcher is required when configuring the HTTP interceptor.');\n        }\n\n        return route.uriMatcher ? route.uriMatcher(request.url) : testPrimitive(route.uri);\n      }\n\n      return testPrimitive(route);\n    }\n    /**\n     * Tries to match a route from the SDK configuration to the HTTP request.\n     * If a match is found, the route configuration is returned.\n     * @param request The Http request\n     * @param config HttpInterceptorConfig\n     */\n\n  }, {\n    key: \"findMatchingRoute\",\n    value: function findMatchingRoute(request, config) {\n      var _this16 = this;\n\n      return from(config.allowedList).pipe(first(function (route) {\n        return _this16.canAttachToken(route, request);\n      }, null));\n    }\n  }, {\n    key: \"allowAnonymous\",\n    value: function allowAnonymous(route, err) {\n      return !!route && isHttpInterceptorRouteConfig(route) && !!route.allowAnonymous && ['login_required', 'consent_required'].includes(err.error);\n    }\n  }]);\n\n  return AuthHttpInterceptor;\n}();\n\nAuthHttpInterceptor.ɵfac = function AuthHttpInterceptor_Factory(t) {\n  return new (t || AuthHttpInterceptor)(ɵngcc0.ɵɵinject(AuthClientConfig), ɵngcc0.ɵɵinject(Auth0ClientService), ɵngcc0.ɵɵinject(AuthState));\n};\n\nAuthHttpInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: AuthHttpInterceptor,\n  factory: AuthHttpInterceptor.ɵfac\n});\n\nAuthHttpInterceptor.ctorParameters = function () {\n  return [{\n    type: AuthClientConfig\n  }, {\n    type: Auth0Client,\n    decorators: [{\n      type: Inject,\n      args: [Auth0ClientService]\n    }]\n  }, {\n    type: AuthState\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthHttpInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthClientConfig\n    }, {\n      type: ɵngcc2.Auth0Client,\n      decorators: [{\n        type: Inject,\n        args: [Auth0ClientService]\n      }]\n    }, {\n      type: AuthState\n    }];\n  }, null);\n})();\n/*\n * Public API Surface of auth0-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Auth0ClientFactory, Auth0ClientService, AuthClientConfig, AuthConfigService, AuthGuard, AuthHttpInterceptor, AuthModule, AuthService, AuthState, isHttpInterceptorRouteConfig, AbstractNavigator as ɵa }; //# sourceMappingURL=auth0-auth0-angular.js.map","map":{"version":3,"sources":["C:/Users/Fernando Martinez/Documents/Programacion/SignWriter/Frontend JD/node_modules/@auth0/auth0-angular/__ivy_ngcc__/fesm2015/auth0-auth0-angular.js"],"names":["i0","InjectionToken","Injectable","Injector","Optional","Inject","NgModule","Auth0Client","ɵngcc0","ɵngcc1","ɵngcc2","InMemoryCache","LocalStorageCache","User","BehaviorSubject","Subject","ReplaySubject","merge","defer","of","iif","from","throwError","scan","filter","distinctUntilChanged","switchMap","mergeMap","shareReplay","concatMap","catchError","tap","takeUntil","withLatestFrom","map","take","pluck","first","__rest","Router","i1","Location","useragent","name","version","Auth0ClientFactory","configFactory","config","get","Error","redirectUri","clientId","maxAge","httpInterceptor","rest","Object","assign","redirect_uri","window","location","origin","client_id","max_age","auth0Client","Auth0ClientService","AbstractNavigator","injector","router","_a","url","navigateByUrl","replaceState","ɵfac","AbstractNavigator_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","factory","INJECTOR","token","providedIn","ctorParameters","type","ngDevMode","ɵsetClassMetadata","args","isHttpInterceptorRouteConfig","def","AuthClientConfig","set","AuthClientConfig_Factory","AuthConfigService","undefined","decorators","AuthState","isLoadingSubject$","refresh$","accessToken$","errorSubject$","isLoading$","asObservable","accessTokenTrigger$","pipe","acc","current","previous","isAuthenticatedTrigger$","loading","isAuthenticated","isAuthenticated$","user$","authenticated","getUser","idTokenClaims$","getIdTokenClaims","error$","isLoading","next","accessToken","error","AuthState_Factory","AuthService","navigator","authState","appStateSubject$","ngUnsubscribe$","appState$","checkSessionOrCallback$","isCallback","handleRedirectCallback","checkSession","shouldHandleCallback","setError","errorPath","setIsLoading","subscribe","complete","options","loginWithRedirect","loginWithPopup","then","refresh","logout","localOnly","client","detailedResponse","getTokenSilently","setAccessToken","access_token","getTokenWithPopup","result","appState","target","buildAuthorizeUrl","buildLogoutUrl","search","includes","skipRedirectCallback","AuthService_Factory","AuthGuard","auth","route","segments","state","redirectIfUnauthenticated","childRoute","loggedIn","AuthGuard_Factory","AuthModule","ngModule","providers","provide","useValue","useFactory","createClient","deps","AuthModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","AuthHttpInterceptor","req","allowedList","handle","findMatchingRoute","getAccessTokenSilently","err","allowAnonymous","clone","headers","uri","indexOf","substr","request","testPrimitive","value","requestPath","stripQueryFrom","length","startsWith","httpMethod","method","uriMatcher","console","warn","canAttachToken","AuthHttpInterceptor_Factory","ɵa"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Injector, Optional, Inject, NgModule } from '@angular/core';\nimport { Auth0Client } from '@auth0/auth0-spa-js';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@auth0/auth0-spa-js';\nexport { InMemoryCache, LocalStorageCache, User } from '@auth0/auth0-spa-js';\nimport { BehaviorSubject, Subject, ReplaySubject, merge, defer, of, iif, from, throwError } from 'rxjs';\nimport { scan, filter, distinctUntilChanged, switchMap, mergeMap, shareReplay, concatMap, catchError, tap, takeUntil, withLatestFrom, map, take, pluck, first } from 'rxjs/operators';\nimport { __rest } from 'tslib';\nimport { Router } from '@angular/router';\nimport * as i1 from '@angular/common';\nimport { Location } from '@angular/common';\n\nvar useragent = { name: '@auth0/auth0-angular', version: '1.9.0' };\n\nclass Auth0ClientFactory {\n    static createClient(configFactory) {\n        const config = configFactory.get();\n        if (!config) {\n            throw new Error('Configuration must be specified either through AuthModule.forRoot or through AuthClientConfig.set');\n        }\n        const { redirectUri, clientId, maxAge, httpInterceptor } = config, rest = __rest(config, [\"redirectUri\", \"clientId\", \"maxAge\", \"httpInterceptor\"]);\n        return new Auth0Client(Object.assign(Object.assign({ redirect_uri: redirectUri || window.location.origin, client_id: clientId, max_age: maxAge }, rest), { auth0Client: {\n                name: useragent.name,\n                version: useragent.version,\n            } }));\n    }\n}\nconst Auth0ClientService = new InjectionToken('auth0.client');\n\nclass AbstractNavigator {\n    constructor(location, injector) {\n        this.location = location;\n        try {\n            this.router = injector.get(Router);\n        }\n        catch (_a) { }\n    }\n    /**\n     * Navigates to the specified url. The router will be used if one is available, otherwise it falls back\n     * to `window.history.replaceState`.\n     * @param url The url to navigate to\n     */\n    navigateByUrl(url) {\n        if (this.router) {\n            this.router.navigateByUrl(url);\n            return;\n        }\n        this.location.replaceState(url);\n    }\n}\nAbstractNavigator.ɵfac = function AbstractNavigator_Factory(t) { return new (t || AbstractNavigator)(ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };\nAbstractNavigator.ɵprov = i0.ɵɵdefineInjectable({ factory: function AbstractNavigator_Factory() { return new AbstractNavigator(i0.ɵɵinject(i1.Location), i0.ɵɵinject(i0.INJECTOR)); }, token: AbstractNavigator, providedIn: \"root\" });\nAbstractNavigator.ctorParameters = () => [\n    { type: Location },\n    { type: Injector }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AbstractNavigator, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: ɵngcc1.Location }, { type: ɵngcc0.Injector }]; }, null); })();\n\n/**\n * A custom type guard to help identify route definitions that are actually HttpInterceptorRouteConfig types.\n * @param def The route definition type\n */\nfunction isHttpInterceptorRouteConfig(def) {\n    return typeof def !== 'string';\n}\n/**\n * Gets and sets configuration for the internal Auth0 client. This can be\n * used to provide configuration outside of using AuthModule.forRoot, i.e. from\n * a factory provided by APP_INITIALIZER.\n *\n * @usage\n *\n * ```js\n * // app.module.ts\n * // ---------------------------\n * import { AuthModule, AuthClientConfig } from '@auth0/auth0-angular';\n *\n * // Provide an initializer function that returns a Promise\n * function configInitializer(\n *   http: HttpClient,\n *   config: AuthClientConfig\n * ) {\n *   return () =>\n *     http\n *       .get('/config')\n *       .toPromise()\n *       .then((loadedConfig: any) => config.set(loadedConfig));   // Set the config that was loaded asynchronously here\n * }\n *\n * // Provide APP_INITIALIZER with this function. Note that there is no config passed to AuthModule.forRoot\n * imports: [\n *   // other imports..\n *\n *   HttpClientModule,\n *   AuthModule.forRoot(),   //<- don't pass any config here\n * ],\n * providers: [\n *   {\n *     provide: APP_INITIALIZER,\n *     useFactory: configInitializer,    // <- pass your initializer function here\n *     deps: [HttpClient, AuthClientConfig],\n *     multi: true,\n *   },\n * ],\n * ```\n *\n */\nclass AuthClientConfig {\n    constructor(config) {\n        if (config) {\n            this.set(config);\n        }\n    }\n    /**\n     * Sets configuration to be read by other consumers of the service (see usage notes)\n     * @param config The configuration to set\n     */\n    set(config) {\n        this.config = config;\n    }\n    /**\n     * Gets the config that has been set by other consumers of the service\n     */\n    get() {\n        return this.config;\n    }\n}\nAuthClientConfig.ɵfac = function AuthClientConfig_Factory(t) { return new (t || AuthClientConfig)(ɵngcc0.ɵɵinject(AuthConfigService, 8)); };\nAuthClientConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthClientConfig_Factory() { return new AuthClientConfig(i0.ɵɵinject(AuthConfigService, 8)); }, token: AuthClientConfig, providedIn: \"root\" });\nAuthClientConfig.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [AuthConfigService,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthClientConfig, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [AuthConfigService]\n            }] }]; }, null); })();\n/**\n * Injection token for accessing configuration.\n *\n * @usageNotes\n *\n * Use the `Inject` decorator to access the configuration from a service or component:\n *\n * ```\n * class MyService(@Inject(AuthConfigService) config: AuthConfig) {}\n * ```\n */\nconst AuthConfigService = new InjectionToken('auth0-angular.config');\n\n/**\n * Tracks the Authentication State for the SDK\n */\nclass AuthState {\n    constructor(auth0Client) {\n        this.auth0Client = auth0Client;\n        this.isLoadingSubject$ = new BehaviorSubject(true);\n        this.refresh$ = new Subject();\n        this.accessToken$ = new ReplaySubject(1);\n        this.errorSubject$ = new ReplaySubject(1);\n        /**\n         * Emits boolean values indicating the loading state of the SDK.\n         */\n        this.isLoading$ = this.isLoadingSubject$.asObservable();\n        /**\n         * Trigger used to pull User information from the Auth0Client.\n         * Triggers when the access token has changed.\n         */\n        this.accessTokenTrigger$ = this.accessToken$.pipe(scan((acc, current) => {\n            return {\n                previous: acc.current,\n                current,\n            };\n        }, { current: null, previous: null }), filter(({ previous, current }) => previous !== current));\n        /**\n         * Trigger used to pull User information from the Auth0Client.\n         * Triggers when an event occurs that needs to retrigger the User Profile information.\n         * Events: Login, Access Token change and Logout\n         */\n        this.isAuthenticatedTrigger$ = this.isLoading$.pipe(filter((loading) => !loading), distinctUntilChanged(), switchMap(() => \n        // To track the value of isAuthenticated over time, we need to merge:\n        //  - the current value\n        //  - the value whenever the access token changes. (this should always be true of there is an access token\n        //    but it is safer to pass this through this.auth0Client.isAuthenticated() nevertheless)\n        //  - the value whenever refreshState$ emits\n        merge(defer(() => this.auth0Client.isAuthenticated()), this.accessTokenTrigger$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())), this.refresh$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())))));\n        /**\n         * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n         * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n         */\n        this.isAuthenticated$ = this.isAuthenticatedTrigger$.pipe(distinctUntilChanged(), shareReplay(1));\n        /**\n         * Emits details about the authenticated user, or null if not authenticated.\n         */\n        this.user$ = this.isAuthenticatedTrigger$.pipe(concatMap((authenticated) => authenticated ? this.auth0Client.getUser() : of(null)));\n        /**\n         * Emits ID token claims when authenticated, or null if not authenticated.\n         */\n        this.idTokenClaims$ = this.isAuthenticatedTrigger$.pipe(concatMap((authenticated) => authenticated ? this.auth0Client.getIdTokenClaims() : of(null)));\n        /**\n         * Emits errors that occur during login, or when checking for an active session on startup.\n         */\n        this.error$ = this.errorSubject$.asObservable();\n    }\n    /**\n     * Update the isLoading state using the provided value\n     * @param isLoading The new value for isLoading\n     */\n    setIsLoading(isLoading) {\n        this.isLoadingSubject$.next(isLoading);\n    }\n    /**\n     * Refresh the state to ensure the `isAuthenticated`, `user$` and `idTokenClaims$`\n     * reflect the most up-to-date values from  Auth0Client.\n     */\n    refresh() {\n        this.refresh$.next();\n    }\n    /**\n     * Update the access token, doing so will also refresh the state.\n     * @param accessToken The new Access Token\n     */\n    setAccessToken(accessToken) {\n        this.accessToken$.next(accessToken);\n    }\n    /**\n     * Emits the error in the `error$` observable.\n     * @param error The new error\n     */\n    setError(error) {\n        this.errorSubject$.next(error);\n    }\n}\nAuthState.ɵfac = function AuthState_Factory(t) { return new (t || AuthState)(ɵngcc0.ɵɵinject(Auth0ClientService)); };\nAuthState.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthState_Factory() { return new AuthState(i0.ɵɵinject(Auth0ClientService)); }, token: AuthState, providedIn: \"root\" });\nAuthState.ctorParameters = () => [\n    { type: Auth0Client, decorators: [{ type: Inject, args: [Auth0ClientService,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthState, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ɵngcc2.Auth0Client, decorators: [{\n                type: Inject,\n                args: [Auth0ClientService]\n            }] }]; }, null); })();\n\nclass AuthService {\n    constructor(auth0Client, configFactory, navigator, authState) {\n        this.auth0Client = auth0Client;\n        this.configFactory = configFactory;\n        this.navigator = navigator;\n        this.authState = authState;\n        this.appStateSubject$ = new ReplaySubject(1);\n        // https://stackoverflow.com/a/41177163\n        this.ngUnsubscribe$ = new Subject();\n        /**\n         * Emits boolean values indicating the loading state of the SDK.\n         */\n        this.isLoading$ = this.authState.isLoading$;\n        /**\n         * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n         * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n         */\n        this.isAuthenticated$ = this.authState.isAuthenticated$;\n        /**\n         * Emits details about the authenticated user, or null if not authenticated.\n         */\n        this.user$ = this.authState.user$;\n        /**\n         * Emits ID token claims when authenticated, or null if not authenticated.\n         */\n        this.idTokenClaims$ = this.authState.idTokenClaims$;\n        /**\n         * Emits errors that occur during login, or when checking for an active session on startup.\n         */\n        this.error$ = this.authState.error$;\n        /**\n         * Emits the value (if any) that was passed to the `loginWithRedirect` method call\n         * but only **after** `handleRedirectCallback` is first called\n         */\n        this.appState$ = this.appStateSubject$.asObservable();\n        const checkSessionOrCallback$ = (isCallback) => iif(() => isCallback, this.handleRedirectCallback(), defer(() => this.auth0Client.checkSession()));\n        this.shouldHandleCallback()\n            .pipe(switchMap((isCallback) => checkSessionOrCallback$(isCallback).pipe(catchError((error) => {\n            const config = this.configFactory.get();\n            this.authState.setError(error);\n            this.navigator.navigateByUrl(config.errorPath || '/');\n            return of(undefined);\n        }))), tap(() => {\n            this.authState.setIsLoading(false);\n        }), takeUntil(this.ngUnsubscribe$))\n            .subscribe();\n    }\n    /**\n     * Called when the service is destroyed\n     */\n    ngOnDestroy() {\n        // https://stackoverflow.com/a/41177163\n        this.ngUnsubscribe$.next();\n        this.ngUnsubscribe$.complete();\n    }\n    /**\n     * ```js\n     * loginWithRedirect(options);\n     * ```\n     *\n     * Performs a redirect to `/authorize` using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated.\n     *\n     * @param options The login options\n     */\n    loginWithRedirect(options) {\n        return from(this.auth0Client.loginWithRedirect(options));\n    }\n    /**\n     * ```js\n     * await loginWithPopup(options);\n     * ```\n     *\n     * Opens a popup with the `/authorize` URL using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated. If the response is successful,\n     * results will be valid according to their expiration times.\n     *\n     * IMPORTANT: This method has to be called from an event handler\n     * that was started by the user like a button click, for example,\n     * otherwise the popup will be blocked in most browsers.\n     *\n     * @param options The login options\n     * @param config Configuration for the popup window\n     */\n    loginWithPopup(options, config) {\n        return from(this.auth0Client.loginWithPopup(options, config).then(() => {\n            this.authState.refresh();\n        }));\n    }\n    /**\n     * ```js\n     * logout();\n     * ```\n     *\n     * Clears the application session and performs a redirect to `/v2/logout`, using\n     * the parameters provided as arguments, to clear the Auth0 session.\n     * If the `federated` option is specified it also clears the Identity Provider session.\n     * If the `localOnly` option is specified, it only clears the application session.\n     * It is invalid to set both the `federated` and `localOnly` options to `true`,\n     * and an error will be thrown if you do.\n     * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).\n     *\n     * @param options The logout options\n     */\n    logout(options) {\n        const logout = this.auth0Client.logout(options) || of(null);\n        from(logout).subscribe(() => {\n            if (options === null || options === void 0 ? void 0 : options.localOnly) {\n                this.authState.refresh();\n            }\n        });\n    }\n    /**\n     * ```js\n     * getAccessTokenSilently(options).subscribe(token => ...)\n     * ```\n     *\n     * If there's a valid token stored, return it. Otherwise, opens an\n     * iframe with the `/authorize` URL using the parameters provided\n     * as arguments. Random and secure `state` and `nonce` parameters\n     * will be auto-generated. If the response is successful, results\n     * will be valid according to their expiration times.\n     *\n     * If refresh tokens are used, the token endpoint is called directly with the\n     * 'refresh_token' grant. If no refresh token is available to make this call,\n     * the SDK falls back to using an iframe to the '/authorize' URL.\n     *\n     * This method may use a web worker to perform the token call if the in-memory\n     * cache is used.\n     *\n     * If an `audience` value is given to this function, the SDK always falls\n     * back to using an iframe to make the token exchange.\n     *\n     * Note that in all cases, falling back to an iframe requires access to\n     * the `auth0` cookie, and thus will not work in browsers that block third-party\n     * cookies by default (Safari, Brave, etc).\n     *\n     * @param options The options for configuring the token fetch.\n     */\n    getAccessTokenSilently(options = {}) {\n        return of(this.auth0Client).pipe(concatMap((client) => options.detailedResponse === true\n            ? client.getTokenSilently(Object.assign(Object.assign({}, options), { detailedResponse: true }))\n            : client.getTokenSilently(options)), tap((token) => this.authState.setAccessToken(typeof token === 'string' ? token : token.access_token)), catchError((error) => {\n            this.authState.setError(error);\n            this.authState.refresh();\n            return throwError(error);\n        }));\n    }\n    /**\n     * ```js\n     * getTokenWithPopup(options).subscribe(token => ...)\n     * ```\n     *\n     * Get an access token interactively.\n     *\n     * Opens a popup with the `/authorize` URL using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated. If the response is successful,\n     * results will be valid according to their expiration times.\n     */\n    getAccessTokenWithPopup(options) {\n        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenWithPopup(options)), tap((token) => this.authState.setAccessToken(token)), catchError((error) => {\n            this.authState.setError(error);\n            this.authState.refresh();\n            return throwError(error);\n        }));\n    }\n    /**\n     * ```js\n     * getUser(options).subscribe(user => ...);\n     * ```\n     *\n     * Returns the user information if available (decoded\n     * from the `id_token`).\n     *\n     * If you provide an audience or scope, they should match an existing Access Token\n     * (the SDK stores a corresponding ID Token with every Access Token, and uses the\n     * scope and audience to look up the ID Token)\n     *\n     * @remarks\n     *\n     * The returned observable will emit once and then complete.\n     *\n     * @typeparam TUser The type to return, has to extend {@link User}.\n     * @param options The options to get the user\n     */\n    getUser(options) {\n        return defer(() => this.auth0Client.getUser(options));\n    }\n    /**\n     * ```js\n     * getIdTokenClaims(options).subscribe(claims => ...);\n     * ```\n     *\n     * Returns all claims from the id_token if available.\n     *\n     * If you provide an audience or scope, they should match an existing Access Token\n     * (the SDK stores a corresponding ID Token with every Access Token, and uses the\n     * scope and audience to look up the ID Token)\n     *\n     * @remarks\n     *\n     * The returned observable will emit once and then complete.\n     *\n     * @param options The options to get the Id token claims\n     */\n    getIdTokenClaims(options) {\n        return defer(() => this.auth0Client.getIdTokenClaims(options));\n    }\n    /**\n     * ```js\n     * handleRedirectCallback(url).subscribe(result => ...)\n     * ```\n     *\n     * After the browser redirects back to the callback page,\n     * call `handleRedirectCallback` to handle success and error\n     * responses from Auth0. If the response is successful, results\n     * will be valid according to their expiration times.\n     *\n     * Calling this method also refreshes the authentication and user states.\n     *\n     * @param url The URL to that should be used to retrieve the `state` and `code` values. Defaults to `window.location.href` if not given.\n     */\n    handleRedirectCallback(url) {\n        return defer(() => this.auth0Client.handleRedirectCallback(url)).pipe(withLatestFrom(this.authState.isLoading$), tap(([result, isLoading]) => {\n            var _a;\n            if (!isLoading) {\n                this.authState.refresh();\n            }\n            const appState = result === null || result === void 0 ? void 0 : result.appState;\n            const target = (_a = appState === null || appState === void 0 ? void 0 : appState.target) !== null && _a !== void 0 ? _a : '/';\n            if (appState) {\n                this.appStateSubject$.next(appState);\n            }\n            this.navigator.navigateByUrl(target);\n        }), map(([result]) => result));\n    }\n    /**\n     * ```js\n     * buildAuthorizeUrl().subscribe(url => ...)\n     * ```\n     *\n     * Builds an `/authorize` URL for loginWithRedirect using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated.\n     * @param options The options\n     * @returns A URL to the authorize endpoint\n     */\n    buildAuthorizeUrl(options) {\n        return defer(() => this.auth0Client.buildAuthorizeUrl(options));\n    }\n    /**\n     * ```js\n     * buildLogoutUrl().subscribe(url => ...)\n     * ```\n     * Builds a URL to the logout endpoint.\n     *\n     * @param options The options used to configure the parameters that appear in the logout endpoint URL.\n     * @returns a URL to the logout endpoint using the parameters provided as arguments.\n     */\n    buildLogoutUrl(options) {\n        return of(this.auth0Client.buildLogoutUrl(options));\n    }\n    shouldHandleCallback() {\n        return of(location.search).pipe(map((search) => {\n            return ((search.includes('code=') || search.includes('error=')) &&\n                search.includes('state=') &&\n                !this.configFactory.get().skipRedirectCallback);\n        }));\n    }\n}\nAuthService.ɵfac = function AuthService_Factory(t) { return new (t || AuthService)(ɵngcc0.ɵɵinject(Auth0ClientService), ɵngcc0.ɵɵinject(AuthClientConfig), ɵngcc0.ɵɵinject(AbstractNavigator), ɵngcc0.ɵɵinject(AuthState)); };\nAuthService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthService(i0.ɵɵinject(Auth0ClientService), i0.ɵɵinject(AuthClientConfig), i0.ɵɵinject(AbstractNavigator), i0.ɵɵinject(AuthState)); }, token: AuthService, providedIn: \"root\" });\nAuthService.ctorParameters = () => [\n    { type: Auth0Client, decorators: [{ type: Inject, args: [Auth0ClientService,] }] },\n    { type: AuthClientConfig },\n    { type: AbstractNavigator },\n    { type: AuthState }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthService, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: ɵngcc2.Auth0Client, decorators: [{\n                type: Inject,\n                args: [Auth0ClientService]\n            }] }, { type: AuthClientConfig }, { type: AbstractNavigator }, { type: AuthState }]; }, null); })();\n\nclass AuthGuard {\n    constructor(auth) {\n        this.auth = auth;\n    }\n    canLoad(route, segments) {\n        return this.auth.isAuthenticated$.pipe(take(1));\n    }\n    canActivate(next, state) {\n        return this.redirectIfUnauthenticated(state);\n    }\n    canActivateChild(childRoute, state) {\n        return this.redirectIfUnauthenticated(state);\n    }\n    redirectIfUnauthenticated(state) {\n        return this.auth.isAuthenticated$.pipe(tap((loggedIn) => {\n            if (!loggedIn) {\n                this.auth.loginWithRedirect({\n                    appState: { target: state.url },\n                });\n            }\n        }));\n    }\n}\nAuthGuard.ɵfac = function AuthGuard_Factory(t) { return new (t || AuthGuard)(ɵngcc0.ɵɵinject(AuthService)); };\nAuthGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(i0.ɵɵinject(AuthService)); }, token: AuthGuard, providedIn: \"root\" });\nAuthGuard.ctorParameters = () => [\n    { type: AuthService }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthGuard, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], function () { return [{ type: AuthService }]; }, null); })();\n\nclass AuthModule {\n    /**\n     * Initialize the authentication module system. Configuration can either be specified here,\n     * or by calling AuthClientConfig.set (perhaps from an APP_INITIALIZER factory function).\n     * @param config The optional configuration for the SDK.\n     */\n    static forRoot(config) {\n        return {\n            ngModule: AuthModule,\n            providers: [\n                AuthService,\n                AuthGuard,\n                {\n                    provide: AuthConfigService,\n                    useValue: config,\n                },\n                {\n                    provide: Auth0ClientService,\n                    useFactory: Auth0ClientFactory.createClient,\n                    deps: [AuthClientConfig],\n                },\n            ],\n        };\n    }\n}\nAuthModule.ɵfac = function AuthModule_Factory(t) { return new (t || AuthModule)(); };\nAuthModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AuthModule });\nAuthModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthModule, [{\n        type: NgModule\n    }], null, null); })();\n\nclass AuthHttpInterceptor {\n    constructor(configFactory, auth0Client, authState) {\n        this.configFactory = configFactory;\n        this.auth0Client = auth0Client;\n        this.authState = authState;\n    }\n    intercept(req, next) {\n        var _a;\n        const config = this.configFactory.get();\n        if (!((_a = config.httpInterceptor) === null || _a === void 0 ? void 0 : _a.allowedList)) {\n            return next.handle(req);\n        }\n        return this.findMatchingRoute(req, config.httpInterceptor).pipe(concatMap((route) => iif(\n        // Check if a route was matched\n        () => route !== null, \n        // If we have a matching route, call getTokenSilently and attach the token to the\n        // outgoing request\n        of(route).pipe(pluck('tokenOptions'), concatMap((options) => {\n            return this.getAccessTokenSilently(options).pipe(catchError((err) => {\n                if (this.allowAnonymous(route, err)) {\n                    return of('');\n                }\n                this.authState.setError(err);\n                return throwError(err);\n            }));\n        }), switchMap((token) => {\n            // Clone the request and attach the bearer token\n            const clone = token\n                ? req.clone({\n                    headers: req.headers.set('Authorization', `Bearer ${token}`),\n                })\n                : req;\n            return next.handle(clone);\n        })), \n        // If the URI being called was not found in our httpInterceptor config, simply\n        // pass the request through without attaching a token\n        next.handle(req))));\n    }\n    /**\n     * Duplicate of AuthService.getAccessTokenSilently, but with a slightly different error handling.\n     * Only used internally in the interceptor.\n     * @param options The options for configuring the token fetch.\n     */\n    getAccessTokenSilently(options) {\n        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenSilently(options)), tap((token) => this.authState.setAccessToken(token)), catchError((error) => {\n            this.authState.refresh();\n            return throwError(error);\n        }));\n    }\n    /**\n     * Strips the query and fragment from the given uri\n     * @param uri The uri to remove the query and fragment from\n     */\n    stripQueryFrom(uri) {\n        if (uri.indexOf('?') > -1) {\n            uri = uri.substr(0, uri.indexOf('?'));\n        }\n        if (uri.indexOf('#') > -1) {\n            uri = uri.substr(0, uri.indexOf('#'));\n        }\n        return uri;\n    }\n    /**\n     * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against\n     * the interceptor route configuration.\n     * @param route The route to test\n     * @param request The HTTP request\n     */\n    canAttachToken(route, request) {\n        const testPrimitive = (value) => {\n            if (!value) {\n                return false;\n            }\n            const requestPath = this.stripQueryFrom(request.url);\n            if (value === requestPath) {\n                return true;\n            }\n            // If the URL ends with an asterisk, match using startsWith.\n            return (value.indexOf('*') === value.length - 1 &&\n                request.url.startsWith(value.substr(0, value.length - 1)));\n        };\n        if (isHttpInterceptorRouteConfig(route)) {\n            if (route.httpMethod && route.httpMethod !== request.method) {\n                return false;\n            }\n            /* istanbul ignore if */\n            if (!route.uri && !route.uriMatcher) {\n                console.warn('Either a uri or uriMatcher is required when configuring the HTTP interceptor.');\n            }\n            return route.uriMatcher\n                ? route.uriMatcher(request.url)\n                : testPrimitive(route.uri);\n        }\n        return testPrimitive(route);\n    }\n    /**\n     * Tries to match a route from the SDK configuration to the HTTP request.\n     * If a match is found, the route configuration is returned.\n     * @param request The Http request\n     * @param config HttpInterceptorConfig\n     */\n    findMatchingRoute(request, config) {\n        return from(config.allowedList).pipe(first((route) => this.canAttachToken(route, request), null));\n    }\n    allowAnonymous(route, err) {\n        return (!!route &&\n            isHttpInterceptorRouteConfig(route) &&\n            !!route.allowAnonymous &&\n            ['login_required', 'consent_required'].includes(err.error));\n    }\n}\nAuthHttpInterceptor.ɵfac = function AuthHttpInterceptor_Factory(t) { return new (t || AuthHttpInterceptor)(ɵngcc0.ɵɵinject(AuthClientConfig), ɵngcc0.ɵɵinject(Auth0ClientService), ɵngcc0.ɵɵinject(AuthState)); };\nAuthHttpInterceptor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AuthHttpInterceptor, factory: AuthHttpInterceptor.ɵfac });\nAuthHttpInterceptor.ctorParameters = () => [\n    { type: AuthClientConfig },\n    { type: Auth0Client, decorators: [{ type: Inject, args: [Auth0ClientService,] }] },\n    { type: AuthState }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthHttpInterceptor, [{\n        type: Injectable\n    }], function () { return [{ type: AuthClientConfig }, { type: ɵngcc2.Auth0Client, decorators: [{\n                type: Inject,\n                args: [Auth0ClientService]\n            }] }, { type: AuthState }]; }, null); })();\n\n/*\n * Public API Surface of auth0-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Auth0ClientFactory, Auth0ClientService, AuthClientConfig, AuthConfigService, AuthGuard, AuthHttpInterceptor, AuthModule, AuthService, AuthState, isHttpInterceptorRouteConfig, AbstractNavigator as ɵa };\n\n//# sourceMappingURL=auth0-auth0-angular.js.map"]},"metadata":{},"sourceType":"module"}